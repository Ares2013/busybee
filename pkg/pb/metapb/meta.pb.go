// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: meta.proto

package metapb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Group shard group
type Group int32

const (
	DefaultGroup Group = 0
	EventGroup   Group = 1
	NotifyGroup  Group = 2
	TenantGroup  Group = 3
)

var Group_name = map[int32]string{
	0: "DefaultGroup",
	1: "EventGroup",
	2: "NotifyGroup",
	3: "TenantGroup",
}

var Group_value = map[string]int32{
	"DefaultGroup": 0,
	"EventGroup":   1,
	"NotifyGroup":  2,
	"TenantGroup":  3,
}

func (x Group) String() string {
	return proto.EnumName(Group_name, int32(x))
}

func (Group) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{0}
}

// ExectuionType is is the type of a execution operation
type ExectuionType int32

const (
	// Direct is an executable operation.
	Direct ExectuionType = 0
	// Timer is an timer executable.
	Timer ExectuionType = 1
	// Branch contains several of the operations that will be performed if certain conditions are met.
	Branch ExectuionType = 2
	// Parallel contains multiple sets of operations that can be executed concurrently.
	Parallel ExectuionType = 3
)

var ExectuionType_name = map[int32]string{
	0: "Direct",
	1: "Timer",
	2: "Branch",
	3: "Parallel",
}

var ExectuionType_value = map[string]int32{
	"Direct":   0,
	"Timer":    1,
	"Branch":   2,
	"Parallel": 3,
}

func (x ExectuionType) String() string {
	return proto.EnumName(ExectuionType_name, int32(x))
}

func (ExectuionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{1}
}

// ExprResultType expr execute type
type ExprResultType int32

const (
	BoolResult ExprResultType = 0
	BMResult   ExprResultType = 1
)

var ExprResultType_name = map[int32]string{
	0: "BoolResult",
	1: "BMResult",
}

var ExprResultType_value = map[string]int32{
	"BoolResult": 0,
	"BMResult":   1,
}

func (x ExprResultType) String() string {
	return proto.EnumName(ExprResultType_name, int32(x))
}

func (ExprResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{2}
}

// Workflow is process definition
type Workflow struct {
	ID       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TenantID uint64 `protobuf:"varint,2,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	Name     string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Steps    []Step `protobuf:"bytes,4,rep,name=steps,proto3" json:"steps"`
}

func (m *Workflow) Reset()         { *m = Workflow{} }
func (m *Workflow) String() string { return proto.CompactTextString(m) }
func (*Workflow) ProtoMessage()    {}
func (*Workflow) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{0}
}
func (m *Workflow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Workflow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Workflow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Workflow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Workflow.Merge(m, src)
}
func (m *Workflow) XXX_Size() int {
	return m.Size()
}
func (m *Workflow) XXX_DiscardUnknown() {
	xxx_messageInfo_Workflow.DiscardUnknown(m)
}

var xxx_messageInfo_Workflow proto.InternalMessageInfo

func (m *Workflow) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Workflow) GetTenantID() uint64 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *Workflow) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Workflow) GetSteps() []Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

// WorkflowInstance workflow instance
type WorkflowInstance struct {
	ID          uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Snapshot    Workflow `protobuf:"bytes,2,opt,name=snapshot,proto3" json:"snapshot"`
	Crowd       []byte   `protobuf:"bytes,3,opt,name=crowd,proto3" json:"crowd,omitempty"`
	MaxPerShard uint64   `protobuf:"varint,4,opt,name=maxPerShard,proto3" json:"maxPerShard,omitempty"`
}

func (m *WorkflowInstance) Reset()         { *m = WorkflowInstance{} }
func (m *WorkflowInstance) String() string { return proto.CompactTextString(m) }
func (*WorkflowInstance) ProtoMessage()    {}
func (*WorkflowInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{1}
}
func (m *WorkflowInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInstance.Merge(m, src)
}
func (m *WorkflowInstance) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInstance.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInstance proto.InternalMessageInfo

func (m *WorkflowInstance) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *WorkflowInstance) GetSnapshot() Workflow {
	if m != nil {
		return m.Snapshot
	}
	return Workflow{}
}

func (m *WorkflowInstance) GetCrowd() []byte {
	if m != nil {
		return m.Crowd
	}
	return nil
}

func (m *WorkflowInstance) GetMaxPerShard() uint64 {
	if m != nil {
		return m.MaxPerShard
	}
	return 0
}

// WorkflowInstanceState workflow instance state, uid in [start,end). instance : instanceState = 1 : N
type WorkflowInstanceState struct {
	TenantID   uint64      `protobuf:"varint,1,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	WorkflowID uint64      `protobuf:"varint,2,opt,name=workflowID,proto3" json:"workflowID,omitempty"`
	InstanceID uint64      `protobuf:"varint,3,opt,name=instanceID,proto3" json:"instanceID,omitempty"`
	Start      uint32      `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End        uint32      `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
	States     []StepState `protobuf:"bytes,6,rep,name=states,proto3" json:"states"`
	Version    uint64      `protobuf:"varint,7,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *WorkflowInstanceState) Reset()         { *m = WorkflowInstanceState{} }
func (m *WorkflowInstanceState) String() string { return proto.CompactTextString(m) }
func (*WorkflowInstanceState) ProtoMessage()    {}
func (*WorkflowInstanceState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{2}
}
func (m *WorkflowInstanceState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInstanceState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInstanceState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInstanceState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInstanceState.Merge(m, src)
}
func (m *WorkflowInstanceState) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInstanceState) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInstanceState.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInstanceState proto.InternalMessageInfo

func (m *WorkflowInstanceState) GetTenantID() uint64 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *WorkflowInstanceState) GetWorkflowID() uint64 {
	if m != nil {
		return m.WorkflowID
	}
	return 0
}

func (m *WorkflowInstanceState) GetInstanceID() uint64 {
	if m != nil {
		return m.InstanceID
	}
	return 0
}

func (m *WorkflowInstanceState) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *WorkflowInstanceState) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *WorkflowInstanceState) GetStates() []StepState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *WorkflowInstanceState) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// CountState step count state
type CountState struct {
	Step  string `protobuf:"bytes,1,opt,name=step,proto3" json:"step,omitempty"`
	Count uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *CountState) Reset()         { *m = CountState{} }
func (m *CountState) String() string { return proto.CompactTextString(m) }
func (*CountState) ProtoMessage()    {}
func (*CountState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{3}
}
func (m *CountState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountState.Merge(m, src)
}
func (m *CountState) XXX_Size() int {
	return m.Size()
}
func (m *CountState) XXX_DiscardUnknown() {
	xxx_messageInfo_CountState.DiscardUnknown(m)
}

var xxx_messageInfo_CountState proto.InternalMessageInfo

func (m *CountState) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

func (m *CountState) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// InstanceCountState active instance count state
type InstanceCountState struct {
	Snapshot Workflow     `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot"`
	States   []CountState `protobuf:"bytes,2,rep,name=states,proto3" json:"states"`
	Total    uint64       `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *InstanceCountState) Reset()         { *m = InstanceCountState{} }
func (m *InstanceCountState) String() string { return proto.CompactTextString(m) }
func (*InstanceCountState) ProtoMessage()    {}
func (*InstanceCountState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{4}
}
func (m *InstanceCountState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceCountState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceCountState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceCountState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceCountState.Merge(m, src)
}
func (m *InstanceCountState) XXX_Size() int {
	return m.Size()
}
func (m *InstanceCountState) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceCountState.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceCountState proto.InternalMessageInfo

func (m *InstanceCountState) GetSnapshot() Workflow {
	if m != nil {
		return m.Snapshot
	}
	return Workflow{}
}

func (m *InstanceCountState) GetStates() []CountState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *InstanceCountState) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

// StepState workflow step state.
type StepState struct {
	Step  Step   `protobuf:"bytes,1,opt,name=step,proto3" json:"step"`
	Crowd []byte `protobuf:"bytes,2,opt,name=crowd,proto3" json:"crowd,omitempty"`
}

func (m *StepState) Reset()         { *m = StepState{} }
func (m *StepState) String() string { return proto.CompactTextString(m) }
func (*StepState) ProtoMessage()    {}
func (*StepState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{5}
}
func (m *StepState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepState.Merge(m, src)
}
func (m *StepState) XXX_Size() int {
	return m.Size()
}
func (m *StepState) XXX_DiscardUnknown() {
	xxx_messageInfo_StepState.DiscardUnknown(m)
}

var xxx_messageInfo_StepState proto.InternalMessageInfo

func (m *StepState) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step{}
}

func (m *StepState) GetCrowd() []byte {
	if m != nil {
		return m.Crowd
	}
	return nil
}

// Step is a step of the work flow
type Step struct {
	Name        string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Execution   Execution `protobuf:"bytes,2,opt,name=execution,proto3" json:"execution"`
	EnterAction string    `protobuf:"bytes,3,opt,name=enterAction,proto3" json:"enterAction,omitempty"`
	LeaveAction string    `protobuf:"bytes,4,opt,name=leaveAction,proto3" json:"leaveAction,omitempty"`
}

func (m *Step) Reset()         { *m = Step{} }
func (m *Step) String() string { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()    {}
func (*Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{6}
}
func (m *Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Step.Merge(m, src)
}
func (m *Step) XXX_Size() int {
	return m.Size()
}
func (m *Step) XXX_DiscardUnknown() {
	xxx_messageInfo_Step.DiscardUnknown(m)
}

var xxx_messageInfo_Step proto.InternalMessageInfo

func (m *Step) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Step) GetExecution() Execution {
	if m != nil {
		return m.Execution
	}
	return Execution{}
}

func (m *Step) GetEnterAction() string {
	if m != nil {
		return m.EnterAction
	}
	return ""
}

func (m *Step) GetLeaveAction() string {
	if m != nil {
		return m.LeaveAction
	}
	return ""
}

// Execution is node operation in a seqence of executions.
// A node may have the following roles:
// 1. DirectExecution
// 2. BranchExecution
// 3. ParallelExecution
type Execution struct {
	Type     ExectuionType        `protobuf:"varint,1,opt,name=type,proto3,enum=metapb.ExectuionType" json:"type,omitempty"`
	Timer    *TimerExecution      `protobuf:"bytes,2,opt,name=timer,proto3" json:"timer,omitempty"`
	Direct   *DirectExecution     `protobuf:"bytes,3,opt,name=direct,proto3" json:"direct,omitempty"`
	Branches []ConditionExecution `protobuf:"bytes,4,rep,name=branches,proto3" json:"branches"`
	Parallel ParallelExecution    `protobuf:"bytes,5,opt,name=parallel,proto3" json:"parallel"`
}

func (m *Execution) Reset()         { *m = Execution{} }
func (m *Execution) String() string { return proto.CompactTextString(m) }
func (*Execution) ProtoMessage()    {}
func (*Execution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{7}
}
func (m *Execution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execution.Merge(m, src)
}
func (m *Execution) XXX_Size() int {
	return m.Size()
}
func (m *Execution) XXX_DiscardUnknown() {
	xxx_messageInfo_Execution.DiscardUnknown(m)
}

var xxx_messageInfo_Execution proto.InternalMessageInfo

func (m *Execution) GetType() ExectuionType {
	if m != nil {
		return m.Type
	}
	return Direct
}

func (m *Execution) GetTimer() *TimerExecution {
	if m != nil {
		return m.Timer
	}
	return nil
}

func (m *Execution) GetDirect() *DirectExecution {
	if m != nil {
		return m.Direct
	}
	return nil
}

func (m *Execution) GetBranches() []ConditionExecution {
	if m != nil {
		return m.Branches
	}
	return nil
}

func (m *Execution) GetParallel() ParallelExecution {
	if m != nil {
		return m.Parallel
	}
	return ParallelExecution{}
}

// TimerExecution is a timer performable operation
type TimerExecution struct {
	Condition *Expr  `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition,omitempty"`
	Interval  uint64 `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	NextStep  string `protobuf:"bytes,3,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *TimerExecution) Reset()         { *m = TimerExecution{} }
func (m *TimerExecution) String() string { return proto.CompactTextString(m) }
func (*TimerExecution) ProtoMessage()    {}
func (*TimerExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{8}
}
func (m *TimerExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimerExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimerExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimerExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimerExecution.Merge(m, src)
}
func (m *TimerExecution) XXX_Size() int {
	return m.Size()
}
func (m *TimerExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_TimerExecution.DiscardUnknown(m)
}

var xxx_messageInfo_TimerExecution proto.InternalMessageInfo

func (m *TimerExecution) GetCondition() *Expr {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *TimerExecution) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *TimerExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// ParallelExecution is a parallel execution
type ParallelExecution struct {
	NextStep  string      `protobuf:"bytes,1,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
	Parallels []Execution `protobuf:"bytes,2,rep,name=parallels,proto3" json:"parallels"`
}

func (m *ParallelExecution) Reset()         { *m = ParallelExecution{} }
func (m *ParallelExecution) String() string { return proto.CompactTextString(m) }
func (*ParallelExecution) ProtoMessage()    {}
func (*ParallelExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{9}
}
func (m *ParallelExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParallelExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParallelExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParallelExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParallelExecution.Merge(m, src)
}
func (m *ParallelExecution) XXX_Size() int {
	return m.Size()
}
func (m *ParallelExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_ParallelExecution.DiscardUnknown(m)
}

var xxx_messageInfo_ParallelExecution proto.InternalMessageInfo

func (m *ParallelExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

func (m *ParallelExecution) GetParallels() []Execution {
	if m != nil {
		return m.Parallels
	}
	return nil
}

// DirectExecution is a directly performable operation
type DirectExecution struct {
	NextStep string `protobuf:"bytes,1,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *DirectExecution) Reset()         { *m = DirectExecution{} }
func (m *DirectExecution) String() string { return proto.CompactTextString(m) }
func (*DirectExecution) ProtoMessage()    {}
func (*DirectExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{10}
}
func (m *DirectExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectExecution.Merge(m, src)
}
func (m *DirectExecution) XXX_Size() int {
	return m.Size()
}
func (m *DirectExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectExecution.DiscardUnknown(m)
}

var xxx_messageInfo_DirectExecution proto.InternalMessageInfo

func (m *DirectExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// ConditionExecution is selecting multiple operations to satisfy the operation of the conditional operation
type ConditionExecution struct {
	Condition Expr      `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition"`
	Execution Execution `protobuf:"bytes,2,opt,name=execution,proto3" json:"execution"`
	NextStep  string    `protobuf:"bytes,3,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *ConditionExecution) Reset()         { *m = ConditionExecution{} }
func (m *ConditionExecution) String() string { return proto.CompactTextString(m) }
func (*ConditionExecution) ProtoMessage()    {}
func (*ConditionExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{11}
}
func (m *ConditionExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionExecution.Merge(m, src)
}
func (m *ConditionExecution) XXX_Size() int {
	return m.Size()
}
func (m *ConditionExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionExecution.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionExecution proto.InternalMessageInfo

func (m *ConditionExecution) GetCondition() Expr {
	if m != nil {
		return m.Condition
	}
	return Expr{}
}

func (m *ConditionExecution) GetExecution() Execution {
	if m != nil {
		return m.Execution
	}
	return Execution{}
}

func (m *ConditionExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// Expr expr
type Expr struct {
	Value []byte         `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Type  ExprResultType `protobuf:"varint,2,opt,name=type,proto3,enum=metapb.ExprResultType" json:"type,omitempty"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{12}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.Size()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

func (m *Expr) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Expr) GetType() ExprResultType {
	if m != nil {
		return m.Type
	}
	return BoolResult
}

func init() {
	proto.RegisterEnum("metapb.Group", Group_name, Group_value)
	proto.RegisterEnum("metapb.ExectuionType", ExectuionType_name, ExectuionType_value)
	proto.RegisterEnum("metapb.ExprResultType", ExprResultType_name, ExprResultType_value)
	proto.RegisterType((*Workflow)(nil), "metapb.Workflow")
	proto.RegisterType((*WorkflowInstance)(nil), "metapb.WorkflowInstance")
	proto.RegisterType((*WorkflowInstanceState)(nil), "metapb.WorkflowInstanceState")
	proto.RegisterType((*CountState)(nil), "metapb.CountState")
	proto.RegisterType((*InstanceCountState)(nil), "metapb.InstanceCountState")
	proto.RegisterType((*StepState)(nil), "metapb.StepState")
	proto.RegisterType((*Step)(nil), "metapb.Step")
	proto.RegisterType((*Execution)(nil), "metapb.Execution")
	proto.RegisterType((*TimerExecution)(nil), "metapb.TimerExecution")
	proto.RegisterType((*ParallelExecution)(nil), "metapb.ParallelExecution")
	proto.RegisterType((*DirectExecution)(nil), "metapb.DirectExecution")
	proto.RegisterType((*ConditionExecution)(nil), "metapb.ConditionExecution")
	proto.RegisterType((*Expr)(nil), "metapb.Expr")
}

func init() { proto.RegisterFile("meta.proto", fileDescriptor_3b5ea8fe65782bcc) }

var fileDescriptor_3b5ea8fe65782bcc = []byte{
	// 860 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0x41, 0x6f, 0xe3, 0x44,
	0x14, 0xf6, 0x38, 0x4e, 0x36, 0x79, 0xc9, 0x76, 0xbd, 0xa3, 0xdd, 0x62, 0x2a, 0xe4, 0x8d, 0x7c,
	0x40, 0x21, 0x62, 0xd3, 0x55, 0x10, 0x5c, 0xe0, 0x00, 0x21, 0x15, 0x44, 0x08, 0xb4, 0x72, 0x2b,
	0x71, 0x9e, 0x38, 0x93, 0xc6, 0xc2, 0xf1, 0x58, 0xf6, 0x38, 0x4d, 0x25, 0x7e, 0x44, 0x2f, 0x20,
	0xf1, 0x8f, 0xf6, 0xd8, 0x23, 0xa7, 0x15, 0xa4, 0x12, 0xbf, 0x03, 0xcd, 0x8c, 0xc7, 0x76, 0x52,
	0xb6, 0x20, 0x6e, 0x7e, 0x6f, 0xbe, 0x37, 0xef, 0x7b, 0xdf, 0xfb, 0x26, 0x01, 0x58, 0x53, 0x4e,
	0x46, 0x49, 0xca, 0x38, 0xc3, 0x2d, 0xf1, 0x9d, 0xcc, 0x4f, 0x5e, 0x5e, 0x86, 0x7c, 0x95, 0xcf,
	0x47, 0x01, 0x5b, 0x9f, 0x5e, 0xb2, 0x4b, 0x76, 0x2a, 0x8f, 0xe7, 0xf9, 0x52, 0x46, 0x32, 0x90,
	0x5f, 0xaa, 0xcc, 0xfb, 0x19, 0xda, 0x3f, 0xb2, 0xf4, 0xa7, 0x65, 0xc4, 0xae, 0xf0, 0x31, 0x98,
	0xe1, 0xc2, 0x41, 0x7d, 0x34, 0xb0, 0x26, 0xad, 0xdd, 0xdb, 0x17, 0xe6, 0x6c, 0xea, 0x9b, 0xe1,
	0x02, 0x9f, 0x40, 0x9b, 0xd3, 0x98, 0xc4, 0x7c, 0x36, 0x75, 0x4c, 0x71, 0xea, 0x97, 0x31, 0xc6,
	0x60, 0xc5, 0x64, 0x4d, 0x9d, 0x46, 0x1f, 0x0d, 0x3a, 0xbe, 0xfc, 0xc6, 0x03, 0x68, 0x66, 0x9c,
	0x26, 0x99, 0x63, 0xf5, 0x1b, 0x83, 0xee, 0xb8, 0x37, 0x52, 0xd4, 0x46, 0xe7, 0x9c, 0x26, 0x13,
	0xeb, 0xcd, 0xdb, 0x17, 0x86, 0xaf, 0x00, 0xde, 0xaf, 0x08, 0x6c, 0xdd, 0x7e, 0x16, 0x67, 0x9c,
	0xc4, 0x01, 0x7d, 0x27, 0x8d, 0x31, 0xb4, 0xb3, 0x98, 0x24, 0xd9, 0x8a, 0x71, 0x49, 0xa3, 0x3b,
	0xb6, 0xf5, 0xcd, 0xfa, 0x8e, 0xe2, 0xf6, 0x12, 0x87, 0x9f, 0x41, 0x33, 0x48, 0xd9, 0xd5, 0x42,
	0xf2, 0xeb, 0xf9, 0x2a, 0xc0, 0x7d, 0xe8, 0xae, 0xc9, 0xf6, 0x35, 0x4d, 0xcf, 0x57, 0x24, 0x5d,
	0x38, 0x96, 0x9c, 0xa9, 0x9e, 0xf2, 0xfe, 0x42, 0xf0, 0xfc, 0x90, 0xd8, 0x39, 0x27, 0x9c, 0xee,
	0x89, 0x81, 0x0e, 0xc4, 0x70, 0x01, 0xae, 0x74, 0x91, 0x96, 0xaa, 0x96, 0x11, 0xe7, 0x61, 0x71,
	0xd9, 0x6c, 0x2a, 0x29, 0x59, 0x7e, 0x2d, 0x23, 0xd8, 0x66, 0x9c, 0xa4, 0x5c, 0x32, 0x7a, 0xec,
	0xab, 0x00, 0xdb, 0xd0, 0xa0, 0xf1, 0xc2, 0x69, 0xca, 0x9c, 0xf8, 0xc4, 0xa7, 0xd0, 0xca, 0x04,
	0x99, 0xcc, 0x69, 0x49, 0x85, 0x9f, 0xd6, 0x15, 0x96, 0x34, 0x0b, 0x21, 0x0a, 0x18, 0x76, 0xe0,
	0xd1, 0x86, 0xa6, 0x59, 0xc8, 0x62, 0xe7, 0x91, 0xec, 0xaa, 0x43, 0xef, 0x33, 0x80, 0xaf, 0x59,
	0x1e, 0x73, 0x35, 0x1c, 0x06, 0x4b, 0x2c, 0x46, 0x0e, 0xd6, 0xf1, 0xe5, 0xb7, 0x94, 0x50, 0x20,
	0x8a, 0x79, 0x54, 0xe0, 0xdd, 0x20, 0xc0, 0x5a, 0x98, 0xda, 0x05, 0xf5, 0x1d, 0xa1, 0xff, 0xb8,
	0xa3, 0x57, 0xe5, 0x34, 0xa6, 0x9c, 0x06, 0xeb, 0x8a, 0xea, 0xde, 0x83, 0x71, 0x9e, 0x41, 0x93,
	0x33, 0x4e, 0xa2, 0x42, 0x42, 0x15, 0x78, 0x33, 0xe8, 0x94, 0xf3, 0xe3, 0x0f, 0x6b, 0x93, 0xfc,
	0xb3, 0x05, 0xab, 0xe9, 0xa4, 0x41, 0xcc, 0x9a, 0x41, 0xbc, 0x5f, 0x10, 0x58, 0x02, 0x5a, 0xda,
	0x1b, 0xd5, 0xec, 0xfd, 0x29, 0x74, 0xe8, 0x96, 0x06, 0x39, 0x17, 0x72, 0x2a, 0x23, 0x96, 0x0b,
	0x38, 0xd3, 0x07, 0x45, 0x93, 0x0a, 0x29, 0x4c, 0x47, 0x63, 0x4e, 0xd3, 0xaf, 0x02, 0x59, 0xa8,
	0x1e, 0x4c, 0x3d, 0x25, 0x10, 0x11, 0x25, 0x1b, 0x5a, 0x20, 0x2c, 0x85, 0xa8, 0xa5, 0xbc, 0x1b,
	0x13, 0x3a, 0x65, 0x0b, 0xfc, 0x11, 0x58, 0xfc, 0x3a, 0x51, 0xe4, 0x8e, 0xc6, 0xcf, 0xeb, 0x1c,
	0x78, 0x1e, 0xb2, 0xf8, 0xe2, 0x3a, 0xa1, 0xbe, 0x84, 0xe0, 0x8f, 0xa1, 0xc9, 0xc3, 0x35, 0x4d,
	0x0b, 0xbe, 0xc7, 0x1a, 0x7b, 0x21, 0x92, 0xe5, 0x8d, 0xbe, 0x02, 0x09, 0x7f, 0x2d, 0xc2, 0x94,
	0x06, 0x5c, 0xb2, 0xec, 0x8e, 0xdf, 0xd3, 0xf0, 0xa9, 0xcc, 0x56, 0xf8, 0x02, 0x86, 0xbf, 0x80,
	0xf6, 0x3c, 0x25, 0x71, 0xb0, 0xa2, 0xfa, 0xd1, 0x9f, 0x54, 0x4b, 0x8c, 0x17, 0xa1, 0x00, 0x1f,
	0x4a, 0x53, 0x56, 0xe0, 0xcf, 0xa1, 0x9d, 0x90, 0x94, 0x44, 0x11, 0x8d, 0xa4, 0xcb, 0xbb, 0xe3,
	0xf7, 0x75, 0xf5, 0xeb, 0x22, 0x7f, 0xaf, 0x58, 0x17, 0x78, 0x1c, 0x8e, 0xf6, 0x87, 0xc0, 0x43,
	0xe8, 0x04, 0xba, 0xe9, 0xe1, 0xfe, 0xcf, 0xb6, 0x49, 0xea, 0x57, 0xc7, 0xe2, 0x35, 0x87, 0x62,
	0x03, 0x1b, 0x12, 0xe9, 0x9f, 0x36, 0x1d, 0x8b, 0xb3, 0x98, 0x6e, 0xb9, 0xf0, 0x41, 0xb1, 0xad,
	0x32, 0xf6, 0x96, 0xf0, 0xf4, 0x1e, 0xb5, 0xbd, 0x02, 0xb4, 0x5f, 0x20, 0x4c, 0xa3, 0x29, 0x6b,
	0x9f, 0xbf, 0xdb, 0x34, 0x25, 0xd2, 0x7b, 0x09, 0x4f, 0x0e, 0x34, 0x7f, 0xa8, 0x8b, 0xf7, 0x1b,
	0x02, 0x7c, 0x5f, 0x70, 0xfc, 0xea, 0x5f, 0x14, 0xd1, 0x7d, 0x2b, 0x5d, 0xfe, 0xa7, 0xc7, 0x1f,
	0x92, 0xec, 0x5b, 0xb0, 0x44, 0x2f, 0xf1, 0xe2, 0x36, 0x24, 0xca, 0x95, 0x6d, 0x7b, 0xbe, 0x0a,
	0xf0, 0xb0, 0xf0, 0xb2, 0x29, 0xbd, 0x7c, 0xbc, 0xb7, 0x2f, 0x9a, 0xe5, 0x11, 0xaf, 0xcc, 0x3c,
	0xfc, 0x0e, 0x9a, 0xdf, 0xa4, 0x2c, 0x4f, 0xb0, 0x0d, 0xbd, 0x29, 0x5d, 0x92, 0x3c, 0xe2, 0x32,
	0xb6, 0x0d, 0x7c, 0x04, 0x70, 0xb6, 0xa1, 0x71, 0x11, 0x23, 0xfc, 0x04, 0xba, 0x3f, 0x30, 0x1e,
	0x2e, 0xaf, 0x55, 0xc2, 0x14, 0x89, 0x0b, 0xf9, 0x73, 0xad, 0x12, 0x8d, 0xe1, 0x97, 0xf0, 0x78,
	0xef, 0xc1, 0x60, 0x80, 0x96, 0x92, 0xdc, 0x36, 0x70, 0x07, 0x9a, 0xd2, 0x5c, 0x36, 0x12, 0xe9,
	0x89, 0x34, 0xac, 0x6d, 0xe2, 0x1e, 0xb4, 0xf5, 0xf6, 0xed, 0xc6, 0x70, 0x04, 0x47, 0xfb, 0x34,
	0x05, 0x8b, 0x09, 0x63, 0x91, 0xca, 0xd8, 0x86, 0xc0, 0x4f, 0xbe, 0x2f, 0x22, 0x34, 0xf9, 0xe0,
	0xf6, 0x4f, 0xd7, 0x78, 0xb3, 0x73, 0xd1, 0xed, 0xce, 0x45, 0x7f, 0xec, 0x5c, 0x74, 0x73, 0xe7,
	0x1a, 0xb7, 0x77, 0xae, 0xf1, 0xfb, 0x9d, 0x6b, 0xcc, 0x5b, 0xf2, 0x7f, 0xf9, 0x93, 0xbf, 0x03,
	0x00, 0x00, 0xff, 0xff, 0x6f, 0x9f, 0x95, 0xa5, 0xdc, 0x07, 0x00, 0x00,
}

func (m *Workflow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Workflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Workflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TenantID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxPerShard != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.MaxPerShard))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Crowd) > 0 {
		i -= len(m.Crowd)
		copy(dAtA[i:], m.Crowd)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Crowd)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowInstanceState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInstanceState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInstanceState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x38
	}
	if len(m.States) > 0 {
		for iNdEx := len(m.States) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.States[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.End != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.InstanceID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.InstanceID))
		i--
		dAtA[i] = 0x18
	}
	if m.WorkflowID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.WorkflowID))
		i--
		dAtA[i] = 0x10
	}
	if m.TenantID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CountState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstanceCountState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceCountState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceCountState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if len(m.States) > 0 {
		for iNdEx := len(m.States) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.States[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StepState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Crowd) > 0 {
		i -= len(m.Crowd)
		copy(dAtA[i:], m.Crowd)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Crowd)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Step.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Step) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LeaveAction) > 0 {
		i -= len(m.LeaveAction)
		copy(dAtA[i:], m.LeaveAction)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.LeaveAction)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EnterAction) > 0 {
		i -= len(m.EnterAction)
		copy(dAtA[i:], m.EnterAction)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.EnterAction)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Parallel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Branches) > 0 {
		for iNdEx := len(m.Branches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Branches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Direct != nil {
		{
			size, err := m.Direct.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Timer != nil {
		{
			size, err := m.Timer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimerExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimerExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimerExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Interval != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if m.Condition != nil {
		{
			size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParallelExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParallelExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParallelExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parallels) > 0 {
		for iNdEx := len(m.Parallels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parallels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConditionExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMeta(dAtA []byte, offset int, v uint64) int {
	offset -= sovMeta(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Workflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMeta(uint64(m.ID))
	}
	if m.TenantID != 0 {
		n += 1 + sovMeta(uint64(m.TenantID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	return n
}

func (m *WorkflowInstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMeta(uint64(m.ID))
	}
	l = m.Snapshot.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.Crowd)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.MaxPerShard != 0 {
		n += 1 + sovMeta(uint64(m.MaxPerShard))
	}
	return n
}

func (m *WorkflowInstanceState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantID != 0 {
		n += 1 + sovMeta(uint64(m.TenantID))
	}
	if m.WorkflowID != 0 {
		n += 1 + sovMeta(uint64(m.WorkflowID))
	}
	if m.InstanceID != 0 {
		n += 1 + sovMeta(uint64(m.InstanceID))
	}
	if m.Start != 0 {
		n += 1 + sovMeta(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovMeta(uint64(m.End))
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovMeta(uint64(m.Version))
	}
	return n
}

func (m *CountState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovMeta(uint64(m.Count))
	}
	return n
}

func (m *InstanceCountState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Snapshot.Size()
	n += 1 + l + sovMeta(uint64(l))
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovMeta(uint64(m.Total))
	}
	return n
}

func (m *StepState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Step.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.Crowd)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = m.Execution.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.EnterAction)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.LeaveAction)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *Execution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMeta(uint64(m.Type))
	}
	if m.Timer != nil {
		l = m.Timer.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Direct != nil {
		l = m.Direct.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	l = m.Parallel.Size()
	n += 1 + l + sovMeta(uint64(l))
	return n
}

func (m *TimerExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovMeta(uint64(m.Interval))
	}
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *ParallelExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Parallels) > 0 {
		for _, e := range m.Parallels {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	return n
}

func (m *DirectExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *ConditionExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Condition.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = m.Execution.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *Expr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMeta(uint64(m.Type))
	}
	return n
}

func sovMeta(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMeta(x uint64) (n int) {
	return sovMeta(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Workflow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Workflow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Workflow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crowd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crowd = append(m.Crowd[:0], dAtA[iNdEx:postIndex]...)
			if m.Crowd == nil {
				m.Crowd = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPerShard", wireType)
			}
			m.MaxPerShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPerShard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInstanceState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInstanceState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInstanceState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowID", wireType)
			}
			m.WorkflowID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkflowID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			m.InstanceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, StepState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceCountState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceCountState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceCountState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, CountState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Step.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crowd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crowd = append(m.Crowd[:0], dAtA[iNdEx:postIndex]...)
			if m.Crowd == nil {
				m.Crowd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaveAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaveAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ExectuionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timer == nil {
				m.Timer = &TimerExecution{}
			}
			if err := m.Timer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Direct == nil {
				m.Direct = &DirectExecution{}
			}
			if err := m.Direct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, ConditionExecution{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parallel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimerExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimerExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimerExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Expr{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parallels = append(m.Parallels, Execution{})
			if err := m.Parallels[len(m.Parallels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ExprResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMeta(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMeta
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMeta
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMeta
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMeta        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMeta          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMeta = fmt.Errorf("proto: unexpected end of group")
)
