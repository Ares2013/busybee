// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: meta.proto

package metapb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ExectuionType is is the type of a execution operation
type ExectuionType int32

const (
	// Direct is an executable operation.
	Direct ExectuionType = 0
	// Timer is an timer executable.
	Timer ExectuionType = 1
	// Branch contains several of the operations that will be performed if certain conditions are met.
	Branch ExectuionType = 2
	// Parallel contains multiple sets of operations that can be executed concurrently.
	Parallel ExectuionType = 3
)

var ExectuionType_name = map[int32]string{
	0: "Direct",
	1: "Timer",
	2: "Branch",
	3: "Parallel",
}

var ExectuionType_value = map[string]int32{
	"Direct":   0,
	"Timer":    1,
	"Branch":   2,
	"Parallel": 3,
}

func (x ExectuionType) String() string {
	return proto.EnumName(ExectuionType_name, int32(x))
}

func (ExectuionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{0}
}

// ExprParmeterType
type ExprParmeterType int32

const (
	String ExprParmeterType = 0
	Number ExprParmeterType = 1
	Bitmap ExprParmeterType = 2
)

var ExprParmeterType_name = map[int32]string{
	0: "String",
	1: "Number",
	2: "Bitmap",
}

var ExprParmeterType_value = map[string]int32{
	"String": 0,
	"Number": 1,
	"Bitmap": 2,
}

func (x ExprParmeterType) String() string {
	return proto.EnumName(ExprParmeterType_name, int32(x))
}

func (ExprParmeterType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{1}
}

// ExprCMP expr cmp operation
type ExprCMP int32

const (
	Equal ExprCMP = 0
	LT    ExprCMP = 1
	LE    ExprCMP = 2
	GT    ExprCMP = 3
	GE    ExprCMP = 4
	Match ExprCMP = 5
)

var ExprCMP_name = map[int32]string{
	0: "Equal",
	1: "LT",
	2: "LE",
	3: "GT",
	4: "GE",
	5: "Match",
}

var ExprCMP_value = map[string]int32{
	"Equal": 0,
	"LT":    1,
	"LE":    2,
	"GT":    3,
	"GE":    4,
	"Match": 5,
}

func (x ExprCMP) String() string {
	return proto.EnumName(ExprCMP_name, int32(x))
}

func (ExprCMP) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{2}
}

// ExprOp operation with sources
type ExprOp int32

const (
	Empty    ExprOp = 0
	BMAnd    ExprOp = 1
	BMOr     ExprOp = 2
	BMXor    ExprOp = 3
	BMAndNot ExprOp = 4
)

var ExprOp_name = map[int32]string{
	0: "Empty",
	1: "BMAnd",
	2: "BMOr",
	3: "BMXor",
	4: "BMAndNot",
}

var ExprOp_value = map[string]int32{
	"Empty":    0,
	"BMAnd":    1,
	"BMOr":     2,
	"BMXor":    3,
	"BMAndNot": 4,
}

func (x ExprOp) String() string {
	return proto.EnumName(ExprOp_name, int32(x))
}

func (ExprOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{3}
}

// ExprFunc operation func
type ExprFunc int32

const (
	First ExprFunc = 0
	Max   ExprFunc = 1
	Min   ExprFunc = 2
	Count ExprFunc = 3
	Avg   ExprFunc = 4
)

var ExprFunc_name = map[int32]string{
	0: "First",
	1: "Max",
	2: "Min",
	3: "Count",
	4: "Avg",
}

var ExprFunc_value = map[string]int32{
	"First": 0,
	"Max":   1,
	"Min":   2,
	"Count": 3,
	"Avg":   4,
}

func (x ExprFunc) String() string {
	return proto.EnumName(ExprFunc_name, int32(x))
}

func (ExprFunc) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{4}
}

// Workflow is process definition
type Workflow struct {
	ID       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TenantID uint64 `protobuf:"varint,2,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	Name     string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Steps    []Step `protobuf:"bytes,4,rep,name=steps,proto3" json:"steps"`
}

func (m *Workflow) Reset()         { *m = Workflow{} }
func (m *Workflow) String() string { return proto.CompactTextString(m) }
func (*Workflow) ProtoMessage()    {}
func (*Workflow) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{0}
}
func (m *Workflow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Workflow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Workflow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Workflow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Workflow.Merge(m, src)
}
func (m *Workflow) XXX_Size() int {
	return m.Size()
}
func (m *Workflow) XXX_DiscardUnknown() {
	xxx_messageInfo_Workflow.DiscardUnknown(m)
}

var xxx_messageInfo_Workflow proto.InternalMessageInfo

func (m *Workflow) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Workflow) GetTenantID() uint64 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *Workflow) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Workflow) GetSteps() []Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

// WorkflowInstance workflow instance
type WorkflowInstance struct {
	ID          uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Snapshot    Workflow `protobuf:"bytes,2,opt,name=snapshot,proto3" json:"snapshot"`
	Crowd       []byte   `protobuf:"bytes,3,opt,name=crowd,proto3" json:"crowd,omitempty"`
	MaxPerShard uint64   `protobuf:"varint,4,opt,name=maxPerShard,proto3" json:"maxPerShard,omitempty"`
}

func (m *WorkflowInstance) Reset()         { *m = WorkflowInstance{} }
func (m *WorkflowInstance) String() string { return proto.CompactTextString(m) }
func (*WorkflowInstance) ProtoMessage()    {}
func (*WorkflowInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{1}
}
func (m *WorkflowInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInstance.Merge(m, src)
}
func (m *WorkflowInstance) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInstance.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInstance proto.InternalMessageInfo

func (m *WorkflowInstance) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *WorkflowInstance) GetSnapshot() Workflow {
	if m != nil {
		return m.Snapshot
	}
	return Workflow{}
}

func (m *WorkflowInstance) GetCrowd() []byte {
	if m != nil {
		return m.Crowd
	}
	return nil
}

func (m *WorkflowInstance) GetMaxPerShard() uint64 {
	if m != nil {
		return m.MaxPerShard
	}
	return 0
}

// WorkflowInstanceState workflow instance state, uid in [start,end). instance : instanceState = 1 : N
type WorkflowInstanceState struct {
	TenantID   uint64      `protobuf:"varint,1,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	WorkflowID uint64      `protobuf:"varint,2,opt,name=workflowID,proto3" json:"workflowID,omitempty"`
	InstanceID uint64      `protobuf:"varint,3,opt,name=instanceID,proto3" json:"instanceID,omitempty"`
	Start      uint32      `protobuf:"varint,4,opt,name=start,proto3" json:"start,omitempty"`
	End        uint32      `protobuf:"varint,5,opt,name=end,proto3" json:"end,omitempty"`
	States     []StepState `protobuf:"bytes,6,rep,name=states,proto3" json:"states"`
	Version    uint64      `protobuf:"varint,7,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *WorkflowInstanceState) Reset()         { *m = WorkflowInstanceState{} }
func (m *WorkflowInstanceState) String() string { return proto.CompactTextString(m) }
func (*WorkflowInstanceState) ProtoMessage()    {}
func (*WorkflowInstanceState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{2}
}
func (m *WorkflowInstanceState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInstanceState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInstanceState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInstanceState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInstanceState.Merge(m, src)
}
func (m *WorkflowInstanceState) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInstanceState) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInstanceState.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInstanceState proto.InternalMessageInfo

func (m *WorkflowInstanceState) GetTenantID() uint64 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *WorkflowInstanceState) GetWorkflowID() uint64 {
	if m != nil {
		return m.WorkflowID
	}
	return 0
}

func (m *WorkflowInstanceState) GetInstanceID() uint64 {
	if m != nil {
		return m.InstanceID
	}
	return 0
}

func (m *WorkflowInstanceState) GetStart() uint32 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *WorkflowInstanceState) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *WorkflowInstanceState) GetStates() []StepState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *WorkflowInstanceState) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// StepState workflow step state.
type StepState struct {
	Step  Step   `protobuf:"bytes,1,opt,name=step,proto3" json:"step"`
	Crowd []byte `protobuf:"bytes,2,opt,name=crowd,proto3" json:"crowd,omitempty"`
}

func (m *StepState) Reset()         { *m = StepState{} }
func (m *StepState) String() string { return proto.CompactTextString(m) }
func (*StepState) ProtoMessage()    {}
func (*StepState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{3}
}
func (m *StepState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepState.Merge(m, src)
}
func (m *StepState) XXX_Size() int {
	return m.Size()
}
func (m *StepState) XXX_DiscardUnknown() {
	xxx_messageInfo_StepState.DiscardUnknown(m)
}

var xxx_messageInfo_StepState proto.InternalMessageInfo

func (m *StepState) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step{}
}

func (m *StepState) GetCrowd() []byte {
	if m != nil {
		return m.Crowd
	}
	return nil
}

// Step is a step of the work flow
type Step struct {
	Name      string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Execution Execution `protobuf:"bytes,2,opt,name=execution,proto3" json:"execution"`
}

func (m *Step) Reset()         { *m = Step{} }
func (m *Step) String() string { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()    {}
func (*Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{4}
}
func (m *Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Step.Merge(m, src)
}
func (m *Step) XXX_Size() int {
	return m.Size()
}
func (m *Step) XXX_DiscardUnknown() {
	xxx_messageInfo_Step.DiscardUnknown(m)
}

var xxx_messageInfo_Step proto.InternalMessageInfo

func (m *Step) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Step) GetExecution() Execution {
	if m != nil {
		return m.Execution
	}
	return Execution{}
}

// Execution is node operation in a seqence of executions.
// A node may have the following roles:
// 1. DirectExecution
// 2. BranchExecution
// 3. ParallelExecution
type Execution struct {
	Type     ExectuionType        `protobuf:"varint,1,opt,name=type,proto3,enum=metapb.ExectuionType" json:"type,omitempty"`
	Timer    *TimerExecution      `protobuf:"bytes,2,opt,name=timer,proto3" json:"timer,omitempty"`
	Direct   *DirectExecution     `protobuf:"bytes,3,opt,name=direct,proto3" json:"direct,omitempty"`
	Branches []ConditionExecution `protobuf:"bytes,4,rep,name=branches,proto3" json:"branches"`
	Parallel ParallelExecution    `protobuf:"bytes,5,opt,name=parallel,proto3" json:"parallel"`
}

func (m *Execution) Reset()         { *m = Execution{} }
func (m *Execution) String() string { return proto.CompactTextString(m) }
func (*Execution) ProtoMessage()    {}
func (*Execution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{5}
}
func (m *Execution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execution.Merge(m, src)
}
func (m *Execution) XXX_Size() int {
	return m.Size()
}
func (m *Execution) XXX_DiscardUnknown() {
	xxx_messageInfo_Execution.DiscardUnknown(m)
}

var xxx_messageInfo_Execution proto.InternalMessageInfo

func (m *Execution) GetType() ExectuionType {
	if m != nil {
		return m.Type
	}
	return Direct
}

func (m *Execution) GetTimer() *TimerExecution {
	if m != nil {
		return m.Timer
	}
	return nil
}

func (m *Execution) GetDirect() *DirectExecution {
	if m != nil {
		return m.Direct
	}
	return nil
}

func (m *Execution) GetBranches() []ConditionExecution {
	if m != nil {
		return m.Branches
	}
	return nil
}

func (m *Execution) GetParallel() ParallelExecution {
	if m != nil {
		return m.Parallel
	}
	return ParallelExecution{}
}

// TimerExecution is a timer performable operation
type TimerExecution struct {
	Condition *Expr  `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition,omitempty"`
	Interval  uint64 `protobuf:"varint,2,opt,name=interval,proto3" json:"interval,omitempty"`
	NextStep  string `protobuf:"bytes,3,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *TimerExecution) Reset()         { *m = TimerExecution{} }
func (m *TimerExecution) String() string { return proto.CompactTextString(m) }
func (*TimerExecution) ProtoMessage()    {}
func (*TimerExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{6}
}
func (m *TimerExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimerExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimerExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimerExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimerExecution.Merge(m, src)
}
func (m *TimerExecution) XXX_Size() int {
	return m.Size()
}
func (m *TimerExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_TimerExecution.DiscardUnknown(m)
}

var xxx_messageInfo_TimerExecution proto.InternalMessageInfo

func (m *TimerExecution) GetCondition() *Expr {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *TimerExecution) GetInterval() uint64 {
	if m != nil {
		return m.Interval
	}
	return 0
}

func (m *TimerExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// ParallelExecution is a parallel execution
type ParallelExecution struct {
	NextStep  string      `protobuf:"bytes,1,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
	Parallels []Execution `protobuf:"bytes,2,rep,name=parallels,proto3" json:"parallels"`
}

func (m *ParallelExecution) Reset()         { *m = ParallelExecution{} }
func (m *ParallelExecution) String() string { return proto.CompactTextString(m) }
func (*ParallelExecution) ProtoMessage()    {}
func (*ParallelExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{7}
}
func (m *ParallelExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParallelExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParallelExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParallelExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParallelExecution.Merge(m, src)
}
func (m *ParallelExecution) XXX_Size() int {
	return m.Size()
}
func (m *ParallelExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_ParallelExecution.DiscardUnknown(m)
}

var xxx_messageInfo_ParallelExecution proto.InternalMessageInfo

func (m *ParallelExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

func (m *ParallelExecution) GetParallels() []Execution {
	if m != nil {
		return m.Parallels
	}
	return nil
}

// DirectExecution is a directly performable operation
type DirectExecution struct {
	NextStep string `protobuf:"bytes,1,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *DirectExecution) Reset()         { *m = DirectExecution{} }
func (m *DirectExecution) String() string { return proto.CompactTextString(m) }
func (*DirectExecution) ProtoMessage()    {}
func (*DirectExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{8}
}
func (m *DirectExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectExecution.Merge(m, src)
}
func (m *DirectExecution) XXX_Size() int {
	return m.Size()
}
func (m *DirectExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectExecution.DiscardUnknown(m)
}

var xxx_messageInfo_DirectExecution proto.InternalMessageInfo

func (m *DirectExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// ConditionExecution is selecting multiple operations to satisfy the operation of the conditional operation
type ConditionExecution struct {
	Condition Expr      `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition"`
	Execution Execution `protobuf:"bytes,2,opt,name=execution,proto3" json:"execution"`
	NextStep  string    `protobuf:"bytes,3,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *ConditionExecution) Reset()         { *m = ConditionExecution{} }
func (m *ConditionExecution) String() string { return proto.CompactTextString(m) }
func (*ConditionExecution) ProtoMessage()    {}
func (*ConditionExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{9}
}
func (m *ConditionExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionExecution.Merge(m, src)
}
func (m *ConditionExecution) XXX_Size() int {
	return m.Size()
}
func (m *ConditionExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionExecution.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionExecution proto.InternalMessageInfo

func (m *ConditionExecution) GetCondition() Expr {
	if m != nil {
		return m.Condition
	}
	return Expr{}
}

func (m *ConditionExecution) GetExecution() Execution {
	if m != nil {
		return m.Execution
	}
	return Execution{}
}

func (m *ConditionExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// Expr expr
type Expr struct {
	Sources []string         `protobuf:"bytes,1,rep,name=sources,proto3" json:"sources,omitempty"`
	Op      ExprOp           `protobuf:"varint,2,opt,name=op,proto3,enum=metapb.ExprOp" json:"op,omitempty"`
	Func    ExprFunc         `protobuf:"varint,3,opt,name=func,proto3,enum=metapb.ExprFunc" json:"func,omitempty"`
	Cmp     ExprCMP          `protobuf:"varint,4,opt,name=cmp,proto3,enum=metapb.ExprCMP" json:"cmp,omitempty"`
	Expect  string           `protobuf:"bytes,5,opt,name=expect,proto3" json:"expect,omitempty"`
	Type    ExprParmeterType `protobuf:"varint,6,opt,name=type,proto3,enum=metapb.ExprParmeterType" json:"type,omitempty"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{10}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.Size()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

func (m *Expr) GetSources() []string {
	if m != nil {
		return m.Sources
	}
	return nil
}

func (m *Expr) GetOp() ExprOp {
	if m != nil {
		return m.Op
	}
	return Empty
}

func (m *Expr) GetFunc() ExprFunc {
	if m != nil {
		return m.Func
	}
	return First
}

func (m *Expr) GetCmp() ExprCMP {
	if m != nil {
		return m.Cmp
	}
	return Equal
}

func (m *Expr) GetExpect() string {
	if m != nil {
		return m.Expect
	}
	return ""
}

func (m *Expr) GetType() ExprParmeterType {
	if m != nil {
		return m.Type
	}
	return String
}

func init() {
	proto.RegisterEnum("metapb.ExectuionType", ExectuionType_name, ExectuionType_value)
	proto.RegisterEnum("metapb.ExprParmeterType", ExprParmeterType_name, ExprParmeterType_value)
	proto.RegisterEnum("metapb.ExprCMP", ExprCMP_name, ExprCMP_value)
	proto.RegisterEnum("metapb.ExprOp", ExprOp_name, ExprOp_value)
	proto.RegisterEnum("metapb.ExprFunc", ExprFunc_name, ExprFunc_value)
	proto.RegisterType((*Workflow)(nil), "metapb.Workflow")
	proto.RegisterType((*WorkflowInstance)(nil), "metapb.WorkflowInstance")
	proto.RegisterType((*WorkflowInstanceState)(nil), "metapb.WorkflowInstanceState")
	proto.RegisterType((*StepState)(nil), "metapb.StepState")
	proto.RegisterType((*Step)(nil), "metapb.Step")
	proto.RegisterType((*Execution)(nil), "metapb.Execution")
	proto.RegisterType((*TimerExecution)(nil), "metapb.TimerExecution")
	proto.RegisterType((*ParallelExecution)(nil), "metapb.ParallelExecution")
	proto.RegisterType((*DirectExecution)(nil), "metapb.DirectExecution")
	proto.RegisterType((*ConditionExecution)(nil), "metapb.ConditionExecution")
	proto.RegisterType((*Expr)(nil), "metapb.Expr")
}

func init() { proto.RegisterFile("meta.proto", fileDescriptor_3b5ea8fe65782bcc) }

var fileDescriptor_3b5ea8fe65782bcc = []byte{
	// 930 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xdf, 0x6f, 0xe3, 0xc4,
	0x13, 0x8f, 0x7f, 0xc4, 0x4d, 0x26, 0xbd, 0xdc, 0xde, 0xea, 0x7b, 0xfd, 0x9a, 0x0a, 0xe5, 0x82,
	0x85, 0x50, 0x88, 0xee, 0x5a, 0x14, 0x04, 0x2f, 0x87, 0x04, 0x4d, 0x9b, 0x43, 0x91, 0xc8, 0x5d,
	0x71, 0x2b, 0xc1, 0xab, 0xe3, 0x6c, 0x13, 0x8b, 0x78, 0xd7, 0xac, 0xd7, 0x6d, 0x2a, 0xf1, 0x47,
	0xdc, 0x13, 0x12, 0xff, 0xd1, 0xbd, 0xd1, 0x47, 0x9e, 0x4e, 0xd0, 0x4a, 0xfc, 0x1d, 0x68, 0xd7,
	0x5e, 0xc7, 0x49, 0xe1, 0x90, 0x78, 0xf2, 0xce, 0xcc, 0x67, 0x66, 0x3e, 0xfb, 0x99, 0xd9, 0x04,
	0x20, 0x26, 0x22, 0x38, 0x48, 0x38, 0x13, 0x0c, 0x3b, 0xf2, 0x9c, 0x4c, 0xf7, 0x9f, 0xcd, 0x23,
	0xb1, 0xc8, 0xa6, 0x07, 0x21, 0x8b, 0x0f, 0xe7, 0x6c, 0xce, 0x0e, 0x55, 0x78, 0x9a, 0x5d, 0x28,
	0x4b, 0x19, 0xea, 0x94, 0xa7, 0x79, 0x3f, 0x41, 0xe3, 0x3b, 0xc6, 0x7f, 0xb8, 0x58, 0xb2, 0x2b,
	0xbc, 0x07, 0x66, 0x34, 0x73, 0x8d, 0xae, 0xd1, 0xb3, 0x87, 0xce, 0xed, 0xdb, 0x27, 0xe6, 0xf8,
	0xc4, 0x37, 0xa3, 0x19, 0xde, 0x87, 0x86, 0x20, 0x34, 0xa0, 0x62, 0x7c, 0xe2, 0x9a, 0x32, 0xea,
	0x97, 0x36, 0xc6, 0x60, 0xd3, 0x20, 0x26, 0xae, 0xd5, 0x35, 0x7a, 0x4d, 0x5f, 0x9d, 0x71, 0x0f,
	0xea, 0xa9, 0x20, 0x49, 0xea, 0xda, 0x5d, 0xab, 0xd7, 0x1a, 0xec, 0x1e, 0xe4, 0xd4, 0x0e, 0xce,
	0x04, 0x49, 0x86, 0xf6, 0x9b, 0xb7, 0x4f, 0x6a, 0x7e, 0x0e, 0xf0, 0x7e, 0x36, 0x00, 0xe9, 0xf6,
	0x63, 0x9a, 0x8a, 0x80, 0x86, 0xe4, 0x1f, 0x69, 0x0c, 0xa0, 0x91, 0xd2, 0x20, 0x49, 0x17, 0x4c,
	0x28, 0x1a, 0xad, 0x01, 0xd2, 0x95, 0x75, 0x8d, 0xa2, 0x7a, 0x89, 0xc3, 0xff, 0x83, 0x7a, 0xc8,
	0xd9, 0xd5, 0x4c, 0xf1, 0xdb, 0xf5, 0x73, 0x03, 0x77, 0xa1, 0x15, 0x07, 0xab, 0x53, 0xc2, 0xcf,
	0x16, 0x01, 0x9f, 0xb9, 0xb6, 0xba, 0x53, 0xd5, 0xe5, 0xfd, 0x69, 0xc0, 0xe3, 0x6d, 0x62, 0x67,
	0x22, 0x10, 0x64, 0x43, 0x0c, 0x63, 0x4b, 0x8c, 0x0e, 0xc0, 0x95, 0x4e, 0xd2, 0x52, 0x55, 0x3c,
	0x32, 0x1e, 0x15, 0xc5, 0xc6, 0x27, 0x8a, 0x92, 0xed, 0x57, 0x3c, 0x92, 0x6d, 0x2a, 0x02, 0x2e,
	0x14, 0xa3, 0x07, 0x7e, 0x6e, 0x60, 0x04, 0x16, 0xa1, 0x33, 0xb7, 0xae, 0x7c, 0xf2, 0x88, 0x0f,
	0xc1, 0x49, 0x25, 0x99, 0xd4, 0x75, 0x94, 0xc2, 0x8f, 0xaa, 0x0a, 0x2b, 0x9a, 0x85, 0x10, 0x05,
	0x0c, 0xbb, 0xb0, 0x73, 0x49, 0x78, 0x1a, 0x31, 0xea, 0xee, 0xa8, 0xae, 0xda, 0xf4, 0xc6, 0xd0,
	0x2c, 0x93, 0xf0, 0x47, 0x60, 0xcb, 0xb9, 0xa8, 0x7b, 0xfd, 0xfd, 0xdc, 0x54, 0x7c, 0xad, 0xaa,
	0x59, 0x51, 0xd5, 0xfb, 0x16, 0x6c, 0x89, 0x2c, 0x57, 0xc2, 0xa8, 0xac, 0xc4, 0x67, 0xd0, 0x24,
	0x2b, 0x12, 0x66, 0x42, 0x52, 0xc8, 0x87, 0x57, 0x92, 0x1e, 0xe9, 0x40, 0xd1, 0x63, 0x8d, 0xf4,
	0x5e, 0x9b, 0xd0, 0x2c, 0xc3, 0xf8, 0x63, 0xb0, 0xc5, 0x75, 0x92, 0x17, 0x6e, 0x0f, 0x1e, 0x57,
	0xf3, 0x45, 0x16, 0x31, 0x7a, 0x7e, 0x9d, 0x10, 0x5f, 0x41, 0xf0, 0x53, 0xa8, 0x8b, 0x28, 0x26,
	0xbc, 0xe8, 0xb5, 0xa7, 0xb1, 0xe7, 0xd2, 0x59, 0x56, 0xf4, 0x73, 0x90, 0xd4, 0x73, 0x16, 0x71,
	0x12, 0x0a, 0x35, 0x93, 0xd6, 0xe0, 0xff, 0x1a, 0x7e, 0xa2, 0xbc, 0x6b, 0x7c, 0x01, 0xc3, 0x5f,
	0x40, 0x63, 0xca, 0x03, 0x1a, 0x2e, 0x88, 0x5e, 0xf2, 0x7d, 0x9d, 0x72, 0xcc, 0xe8, 0x2c, 0x92,
	0xe0, 0xed, 0x6b, 0x95, 0x19, 0xf8, 0x39, 0x34, 0x92, 0x80, 0x07, 0xcb, 0x25, 0x59, 0xaa, 0xa9,
	0xb6, 0x06, 0xef, 0xe9, 0xec, 0xd3, 0xc2, 0x7f, 0x2f, 0x59, 0x27, 0x78, 0x02, 0xda, 0x9b, 0x97,
	0xc0, 0x7d, 0x68, 0x86, 0xba, 0xe9, 0xf6, 0xe8, 0x46, 0xab, 0x84, 0xfb, 0xeb, 0xb0, 0xdc, 0xde,
	0x88, 0x0a, 0xc2, 0x2f, 0x83, 0xa5, 0x7e, 0xca, 0xda, 0x96, 0x31, 0x4a, 0x56, 0x42, 0xce, 0xb0,
	0x78, 0xce, 0xa5, 0xed, 0x5d, 0xc0, 0xa3, 0x7b, 0xd4, 0x36, 0x12, 0x8c, 0xcd, 0x04, 0x39, 0x70,
	0x4d, 0x39, 0x75, 0xcd, 0xcd, 0x2d, 0xbd, 0x37, 0xf0, 0x12, 0xe9, 0x3d, 0x83, 0x87, 0x5b, 0x9a,
	0xbf, 0xab, 0x8b, 0xf7, 0x8b, 0x01, 0xf8, 0xbe, 0xe0, 0xf8, 0x93, 0x7f, 0x51, 0x44, 0xf7, 0x5d,
	0xeb, 0xf2, 0xdf, 0xf6, 0xf3, 0x9d, 0x92, 0xfd, 0x6a, 0x80, 0x2d, 0x9b, 0xc9, 0xc7, 0x97, 0xb2,
	0x8c, 0x87, 0x24, 0x75, 0x8d, 0xae, 0xd5, 0x6b, 0xfa, 0xda, 0xc4, 0x1d, 0x30, 0x59, 0xa2, 0xda,
	0xb5, 0x07, 0xed, 0x2a, 0xc1, 0x57, 0x89, 0x6f, 0xb2, 0x04, 0x7f, 0x08, 0xf6, 0x45, 0x46, 0x43,
	0x55, 0xba, 0xbd, 0xfe, 0xb5, 0x93, 0x88, 0x17, 0x19, 0x0d, 0x7d, 0x15, 0xc5, 0x1f, 0x80, 0x15,
	0xc6, 0x89, 0xfa, 0xcd, 0x68, 0x0f, 0x1e, 0x56, 0x41, 0xc7, 0x93, 0x53, 0x5f, 0xc6, 0xf0, 0x1e,
	0x38, 0x64, 0x95, 0xc8, 0x05, 0xaf, 0x2b, 0x96, 0x85, 0x85, 0x9f, 0x16, 0x2f, 0xca, 0x51, 0xb9,
	0x6e, 0x35, 0xf7, 0x34, 0xe0, 0x31, 0x11, 0x84, 0xaf, 0x1f, 0x55, 0xff, 0x2b, 0x78, 0xb0, 0xf1,
	0xd6, 0x30, 0x80, 0x93, 0x4f, 0x0b, 0xd5, 0x70, 0x13, 0xea, 0x6a, 0x2f, 0x91, 0x21, 0xdd, 0x43,
	0xb5, 0xeb, 0xc8, 0xc4, 0xbb, 0xd0, 0xd0, 0x8b, 0x83, 0xac, 0xfe, 0xe7, 0x80, 0xb6, 0x6b, 0x4b,
	0xf4, 0x99, 0xe0, 0x11, 0x9d, 0xa3, 0x9a, 0x3c, 0xbf, 0xcc, 0xe2, 0x69, 0x59, 0x25, 0x12, 0x71,
	0x90, 0x20, 0xb3, 0xff, 0x25, 0xec, 0x14, 0xf7, 0x91, 0x7d, 0x46, 0x3f, 0x66, 0xc1, 0x12, 0xd5,
	0xb0, 0x03, 0xe6, 0x37, 0xe7, 0xc8, 0x50, 0xdf, 0x11, 0x32, 0xe5, 0xf7, 0xeb, 0x73, 0x64, 0xa9,
	0xef, 0x08, 0xd9, 0x12, 0x3a, 0x09, 0x44, 0xb8, 0x40, 0xf5, 0xfe, 0x11, 0x38, 0xb9, 0xae, 0x2a,
	0x3f, 0x4e, 0xc4, 0x75, 0x4e, 0x79, 0x38, 0x39, 0xa2, 0x33, 0x64, 0xe0, 0x06, 0xd8, 0xc3, 0xc9,
	0x2b, 0x8e, 0xcc, 0xdc, 0xf9, 0x3d, 0xe3, 0xc8, 0x92, 0xdc, 0x55, 0xfc, 0x25, 0x13, 0xc8, 0xee,
	0x3f, 0x87, 0x86, 0x16, 0x5e, 0x82, 0x5e, 0x44, 0x3c, 0x95, 0xf7, 0xde, 0x01, 0x6b, 0x12, 0xac,
	0x90, 0xa1, 0x0e, 0x11, 0xcd, 0x2b, 0x1c, 0xb3, 0x8c, 0x0a, 0x64, 0x49, 0xdf, 0xd1, 0xe5, 0x1c,
	0xd9, 0xc3, 0xf7, 0x6f, 0xfe, 0xe8, 0xd4, 0xde, 0xdc, 0x76, 0x8c, 0x9b, 0xdb, 0x8e, 0xf1, 0xfb,
	0x6d, 0xc7, 0x78, 0x7d, 0xd7, 0xa9, 0xdd, 0xdc, 0x75, 0x6a, 0xbf, 0xdd, 0x75, 0x6a, 0x53, 0x47,
	0xfd, 0x17, 0x7f, 0xfa, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x52, 0x4e, 0x9c, 0x61, 0xd0, 0x07,
	0x00, 0x00,
}

func (m *Workflow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Workflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Workflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TenantID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxPerShard != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.MaxPerShard))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Crowd) > 0 {
		i -= len(m.Crowd)
		copy(dAtA[i:], m.Crowd)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Crowd)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowInstanceState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInstanceState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInstanceState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x38
	}
	if len(m.States) > 0 {
		for iNdEx := len(m.States) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.States[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.End != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x28
	}
	if m.Start != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x20
	}
	if m.InstanceID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.InstanceID))
		i--
		dAtA[i] = 0x18
	}
	if m.WorkflowID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.WorkflowID))
		i--
		dAtA[i] = 0x10
	}
	if m.TenantID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StepState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Crowd) > 0 {
		i -= len(m.Crowd)
		copy(dAtA[i:], m.Crowd)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Crowd)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Step.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Step) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Parallel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Branches) > 0 {
		for iNdEx := len(m.Branches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Branches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Direct != nil {
		{
			size, err := m.Direct.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Timer != nil {
		{
			size, err := m.Timer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimerExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimerExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimerExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Interval != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x10
	}
	if m.Condition != nil {
		{
			size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParallelExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParallelExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParallelExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parallels) > 0 {
		for iNdEx := len(m.Parallels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parallels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConditionExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Expect) > 0 {
		i -= len(m.Expect)
		copy(dAtA[i:], m.Expect)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Expect)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Cmp != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Cmp))
		i--
		dAtA[i] = 0x20
	}
	if m.Func != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Func))
		i--
		dAtA[i] = 0x18
	}
	if m.Op != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Sources) > 0 {
		for iNdEx := len(m.Sources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Sources[iNdEx])
			copy(dAtA[i:], m.Sources[iNdEx])
			i = encodeVarintMeta(dAtA, i, uint64(len(m.Sources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintMeta(dAtA []byte, offset int, v uint64) int {
	offset -= sovMeta(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Workflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMeta(uint64(m.ID))
	}
	if m.TenantID != 0 {
		n += 1 + sovMeta(uint64(m.TenantID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	return n
}

func (m *WorkflowInstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMeta(uint64(m.ID))
	}
	l = m.Snapshot.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.Crowd)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.MaxPerShard != 0 {
		n += 1 + sovMeta(uint64(m.MaxPerShard))
	}
	return n
}

func (m *WorkflowInstanceState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantID != 0 {
		n += 1 + sovMeta(uint64(m.TenantID))
	}
	if m.WorkflowID != 0 {
		n += 1 + sovMeta(uint64(m.WorkflowID))
	}
	if m.InstanceID != 0 {
		n += 1 + sovMeta(uint64(m.InstanceID))
	}
	if m.Start != 0 {
		n += 1 + sovMeta(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovMeta(uint64(m.End))
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovMeta(uint64(m.Version))
	}
	return n
}

func (m *StepState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Step.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.Crowd)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = m.Execution.Size()
	n += 1 + l + sovMeta(uint64(l))
	return n
}

func (m *Execution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMeta(uint64(m.Type))
	}
	if m.Timer != nil {
		l = m.Timer.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Direct != nil {
		l = m.Direct.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	l = m.Parallel.Size()
	n += 1 + l + sovMeta(uint64(l))
	return n
}

func (m *TimerExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Interval != 0 {
		n += 1 + sovMeta(uint64(m.Interval))
	}
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *ParallelExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Parallels) > 0 {
		for _, e := range m.Parallels {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	return n
}

func (m *DirectExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *ConditionExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Condition.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = m.Execution.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *Expr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sources) > 0 {
		for _, s := range m.Sources {
			l = len(s)
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Op != 0 {
		n += 1 + sovMeta(uint64(m.Op))
	}
	if m.Func != 0 {
		n += 1 + sovMeta(uint64(m.Func))
	}
	if m.Cmp != 0 {
		n += 1 + sovMeta(uint64(m.Cmp))
	}
	l = len(m.Expect)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMeta(uint64(m.Type))
	}
	return n
}

func sovMeta(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMeta(x uint64) (n int) {
	return sovMeta(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Workflow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Workflow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Workflow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crowd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crowd = append(m.Crowd[:0], dAtA[iNdEx:postIndex]...)
			if m.Crowd == nil {
				m.Crowd = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPerShard", wireType)
			}
			m.MaxPerShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPerShard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInstanceState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInstanceState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInstanceState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowID", wireType)
			}
			m.WorkflowID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkflowID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			m.InstanceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, StepState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Step.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crowd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crowd = append(m.Crowd[:0], dAtA[iNdEx:postIndex]...)
			if m.Crowd == nil {
				m.Crowd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ExectuionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timer == nil {
				m.Timer = &TimerExecution{}
			}
			if err := m.Timer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Direct == nil {
				m.Direct = &DirectExecution{}
			}
			if err := m.Direct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, ConditionExecution{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parallel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimerExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimerExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimerExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Expr{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parallels = append(m.Parallels, Execution{})
			if err := m.Parallels[len(m.Parallels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sources", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sources = append(m.Sources, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= ExprOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			m.Func = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Func |= ExprFunc(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmp", wireType)
			}
			m.Cmp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmp |= ExprCMP(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ExprParmeterType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMeta(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMeta
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMeta
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMeta
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMeta        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMeta          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMeta = fmt.Errorf("proto: unexpected end of group")
)
