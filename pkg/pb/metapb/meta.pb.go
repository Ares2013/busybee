// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: meta.proto

package metapb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BMLoader bitmap loader type
type BMLoader int32

const (
	RawLoader        BMLoader = 0
	KVLoader         BMLoader = 1
	KVShardLoader    BMLoader = 2
	ClickhouseLoader BMLoader = 3
)

var BMLoader_name = map[int32]string{
	0: "RawLoader",
	1: "KVLoader",
	2: "KVShardLoader",
	3: "ClickhouseLoader",
}

var BMLoader_value = map[string]int32{
	"RawLoader":        0,
	"KVLoader":         1,
	"KVShardLoader":    2,
	"ClickhouseLoader": 3,
}

func (x BMLoader) String() string {
	return proto.EnumName(BMLoader_name, int32(x))
}

func (BMLoader) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{0}
}

// WorkflowInstanceState workflow instance state
type WorkflowInstanceState int32

const (
	Starting WorkflowInstanceState = 0
	Running  WorkflowInstanceState = 1
	Stopping WorkflowInstanceState = 2
	Stopped  WorkflowInstanceState = 3
)

var WorkflowInstanceState_name = map[int32]string{
	0: "Starting",
	1: "Running",
	2: "Stopping",
	3: "Stopped",
}

var WorkflowInstanceState_value = map[string]int32{
	"Starting": 0,
	"Running":  1,
	"Stopping": 2,
	"Stopped":  3,
}

func (x WorkflowInstanceState) String() string {
	return proto.EnumName(WorkflowInstanceState_name, int32(x))
}

func (WorkflowInstanceState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{1}
}

// EventType tenant input event type
type EventType int32

const (
	UserType           EventType = 0
	UpdateCrowdType    EventType = 1
	UpdateWorkflowType EventType = 2
)

var EventType_name = map[int32]string{
	0: "UserType",
	1: "UpdateCrowdType",
	2: "UpdateWorkflowType",
}

var EventType_value = map[string]int32{
	"UserType":           0,
	"UpdateCrowdType":    1,
	"UpdateWorkflowType": 2,
}

func (x EventType) String() string {
	return proto.EnumName(EventType_name, int32(x))
}

func (EventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{2}
}

// Group shard group
type Group int32

const (
	DefaultGroup      Group = 0
	TenantInputGroup  Group = 1
	TenantOutputGroup Group = 2
)

var Group_name = map[int32]string{
	0: "DefaultGroup",
	1: "TenantInputGroup",
	2: "TenantOutputGroup",
}

var Group_value = map[string]int32{
	"DefaultGroup":      0,
	"TenantInputGroup":  1,
	"TenantOutputGroup": 2,
}

func (x Group) String() string {
	return proto.EnumName(Group_name, int32(x))
}

func (Group) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{3}
}

// ExectuionType is is the type of a execution operation
type ExectuionType int32

const (
	// Direct is an executable operation.
	Direct ExectuionType = 0
	// Timer is an timer executable.
	Timer ExectuionType = 1
	// Branch contains several of the operations that will be performed if certain conditions are met.
	Branch ExectuionType = 2
	// Parallel contains multiple sets of operations that can be executed concurrently.
	Parallel ExectuionType = 3
)

var ExectuionType_name = map[int32]string{
	0: "Direct",
	1: "Timer",
	2: "Branch",
	3: "Parallel",
}

var ExectuionType_value = map[string]int32{
	"Direct":   0,
	"Timer":    1,
	"Branch":   2,
	"Parallel": 3,
}

func (x ExectuionType) String() string {
	return proto.EnumName(ExectuionType_name, int32(x))
}

func (ExectuionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{4}
}

// ExprResultType expr execute type
type ExprResultType int32

const (
	BoolResult ExprResultType = 0
	BMResult   ExprResultType = 1
)

var ExprResultType_name = map[int32]string{
	0: "BoolResult",
	1: "BMResult",
}

var ExprResultType_value = map[string]int32{
	"BoolResult": 0,
	"BMResult":   1,
}

func (x ExprResultType) String() string {
	return proto.EnumName(ExprResultType_name, int32(x))
}

func (ExprResultType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{5}
}

// ShardBitmapPutMeta shard bitmap put meta
type ShardBitmapPutMeta struct {
	Key           []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	TTL           uint32 `protobuf:"varint,2,opt,name=ttl,proto3" json:"ttl,omitempty"`
	BytesPerShard uint32 `protobuf:"varint,3,opt,name=bytesPerShard,proto3" json:"bytesPerShard,omitempty"`
}

func (m *ShardBitmapPutMeta) Reset()         { *m = ShardBitmapPutMeta{} }
func (m *ShardBitmapPutMeta) String() string { return proto.CompactTextString(m) }
func (*ShardBitmapPutMeta) ProtoMessage()    {}
func (*ShardBitmapPutMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{0}
}
func (m *ShardBitmapPutMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardBitmapPutMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardBitmapPutMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardBitmapPutMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardBitmapPutMeta.Merge(m, src)
}
func (m *ShardBitmapPutMeta) XXX_Size() int {
	return m.Size()
}
func (m *ShardBitmapPutMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardBitmapPutMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ShardBitmapPutMeta proto.InternalMessageInfo

func (m *ShardBitmapPutMeta) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ShardBitmapPutMeta) GetTTL() uint32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

func (m *ShardBitmapPutMeta) GetBytesPerShard() uint32 {
	if m != nil {
		return m.BytesPerShard
	}
	return 0
}

// ShardBitmapLoadMeta shard bitmap load meta
type ShardBitmapLoadMeta struct {
	Key    []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Total  uint64 `protobuf:"varint,2,opt,name=Total,proto3" json:"Total,omitempty"`
	Shards uint32 `protobuf:"varint,3,opt,name=shards,proto3" json:"shards,omitempty"`
}

func (m *ShardBitmapLoadMeta) Reset()         { *m = ShardBitmapLoadMeta{} }
func (m *ShardBitmapLoadMeta) String() string { return proto.CompactTextString(m) }
func (*ShardBitmapLoadMeta) ProtoMessage()    {}
func (*ShardBitmapLoadMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{1}
}
func (m *ShardBitmapLoadMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardBitmapLoadMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardBitmapLoadMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardBitmapLoadMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardBitmapLoadMeta.Merge(m, src)
}
func (m *ShardBitmapLoadMeta) XXX_Size() int {
	return m.Size()
}
func (m *ShardBitmapLoadMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardBitmapLoadMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ShardBitmapLoadMeta proto.InternalMessageInfo

func (m *ShardBitmapLoadMeta) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ShardBitmapLoadMeta) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ShardBitmapLoadMeta) GetShards() uint32 {
	if m != nil {
		return m.Shards
	}
	return 0
}

// IDValue is a id value
type IDValue struct {
	Value string `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Type  string `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *IDValue) Reset()         { *m = IDValue{} }
func (m *IDValue) String() string { return proto.CompactTextString(m) }
func (*IDValue) ProtoMessage()    {}
func (*IDValue) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{2}
}
func (m *IDValue) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDValue) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDValue.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDValue) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDValue.Merge(m, src)
}
func (m *IDValue) XXX_Size() int {
	return m.Size()
}
func (m *IDValue) XXX_DiscardUnknown() {
	xxx_messageInfo_IDValue.DiscardUnknown(m)
}

var xxx_messageInfo_IDValue proto.InternalMessageInfo

func (m *IDValue) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *IDValue) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// IDSet id set
type IDSet struct {
	Values []IDValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values"`
}

func (m *IDSet) Reset()         { *m = IDSet{} }
func (m *IDSet) String() string { return proto.CompactTextString(m) }
func (*IDSet) ProtoMessage()    {}
func (*IDSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{3}
}
func (m *IDSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IDSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IDSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IDSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IDSet.Merge(m, src)
}
func (m *IDSet) XXX_Size() int {
	return m.Size()
}
func (m *IDSet) XXX_DiscardUnknown() {
	xxx_messageInfo_IDSet.DiscardUnknown(m)
}

var xxx_messageInfo_IDSet proto.InternalMessageInfo

func (m *IDSet) GetValues() []IDValue {
	if m != nil {
		return m.Values
	}
	return nil
}

// Event tenant event
type Event struct {
	Type           EventType            `protobuf:"varint,1,opt,name=type,proto3,enum=metapb.EventType" json:"type,omitempty"`
	User           *UserEvent           `protobuf:"bytes,2,opt,name=user,proto3" json:"user,omitempty"`
	UpdateCrowd    *UpdateCrowdEvent    `protobuf:"bytes,3,opt,name=updateCrowd,proto3" json:"updateCrowd,omitempty"`
	UpdateWorkflow *UpdateWorkflowEvent `protobuf:"bytes,4,opt,name=updateWorkflow,proto3" json:"updateWorkflow,omitempty"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{4}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetType() EventType {
	if m != nil {
		return m.Type
	}
	return UserType
}

func (m *Event) GetUser() *UserEvent {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *Event) GetUpdateCrowd() *UpdateCrowdEvent {
	if m != nil {
		return m.UpdateCrowd
	}
	return nil
}

func (m *Event) GetUpdateWorkflow() *UpdateWorkflowEvent {
	if m != nil {
		return m.UpdateWorkflow
	}
	return nil
}

// UpdateCrowdEvent update crowd event
type UpdateCrowdEvent struct {
	WorkflowID uint64 `protobuf:"varint,1,opt,name=workflowID,proto3" json:"workflowID,omitempty"`
	Index      uint32 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Crowd      []byte `protobuf:"bytes,3,opt,name=crowd,proto3" json:"crowd,omitempty"`
}

func (m *UpdateCrowdEvent) Reset()         { *m = UpdateCrowdEvent{} }
func (m *UpdateCrowdEvent) String() string { return proto.CompactTextString(m) }
func (*UpdateCrowdEvent) ProtoMessage()    {}
func (*UpdateCrowdEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{5}
}
func (m *UpdateCrowdEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateCrowdEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateCrowdEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateCrowdEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateCrowdEvent.Merge(m, src)
}
func (m *UpdateCrowdEvent) XXX_Size() int {
	return m.Size()
}
func (m *UpdateCrowdEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateCrowdEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateCrowdEvent proto.InternalMessageInfo

func (m *UpdateCrowdEvent) GetWorkflowID() uint64 {
	if m != nil {
		return m.WorkflowID
	}
	return 0
}

func (m *UpdateCrowdEvent) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *UpdateCrowdEvent) GetCrowd() []byte {
	if m != nil {
		return m.Crowd
	}
	return nil
}

// UpdateWorkflowEvent update crowd event
type UpdateWorkflowEvent struct {
	Workflow Workflow `protobuf:"bytes,1,opt,name=workflow,proto3" json:"workflow"`
}

func (m *UpdateWorkflowEvent) Reset()         { *m = UpdateWorkflowEvent{} }
func (m *UpdateWorkflowEvent) String() string { return proto.CompactTextString(m) }
func (*UpdateWorkflowEvent) ProtoMessage()    {}
func (*UpdateWorkflowEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{6}
}
func (m *UpdateWorkflowEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateWorkflowEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateWorkflowEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateWorkflowEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateWorkflowEvent.Merge(m, src)
}
func (m *UpdateWorkflowEvent) XXX_Size() int {
	return m.Size()
}
func (m *UpdateWorkflowEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateWorkflowEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateWorkflowEvent proto.InternalMessageInfo

func (m *UpdateWorkflowEvent) GetWorkflow() Workflow {
	if m != nil {
		return m.Workflow
	}
	return Workflow{}
}

// UserEvent is process definition
type UserEvent struct {
	UserID     uint32 `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
	TenantID   uint64 `protobuf:"varint,2,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	WorkflowID uint64 `protobuf:"varint,3,opt,name=workflowID,proto3" json:"workflowID,omitempty"`
	Data       []KV   `protobuf:"bytes,4,rep,name=data,proto3" json:"data"`
}

func (m *UserEvent) Reset()         { *m = UserEvent{} }
func (m *UserEvent) String() string { return proto.CompactTextString(m) }
func (*UserEvent) ProtoMessage()    {}
func (*UserEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{7}
}
func (m *UserEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserEvent.Merge(m, src)
}
func (m *UserEvent) XXX_Size() int {
	return m.Size()
}
func (m *UserEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_UserEvent.DiscardUnknown(m)
}

var xxx_messageInfo_UserEvent proto.InternalMessageInfo

func (m *UserEvent) GetUserID() uint32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *UserEvent) GetTenantID() uint64 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *UserEvent) GetWorkflowID() uint64 {
	if m != nil {
		return m.WorkflowID
	}
	return 0
}

func (m *UserEvent) GetData() []KV {
	if m != nil {
		return m.Data
	}
	return nil
}

// KV custom KV data
type KV struct {
	Key   []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KV) Reset()         { *m = KV{} }
func (m *KV) String() string { return proto.CompactTextString(m) }
func (*KV) ProtoMessage()    {}
func (*KV) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{8}
}
func (m *KV) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KV) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KV.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KV) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KV.Merge(m, src)
}
func (m *KV) XXX_Size() int {
	return m.Size()
}
func (m *KV) XXX_DiscardUnknown() {
	xxx_messageInfo_KV.DiscardUnknown(m)
}

var xxx_messageInfo_KV proto.InternalMessageInfo

func (m *KV) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KV) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// Notify notify message
type Notify struct {
	UserID     uint32 `protobuf:"varint,1,opt,name=userID,proto3" json:"userID,omitempty"`
	Crowd      []byte `protobuf:"bytes,2,opt,name=crowd,proto3" json:"crowd,omitempty"`
	TenantID   uint64 `protobuf:"varint,3,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	WorkflowID uint64 `protobuf:"varint,4,opt,name=workflowID,proto3" json:"workflowID,omitempty"`
	FromStep   string `protobuf:"bytes,5,opt,name=fromStep,proto3" json:"fromStep,omitempty"`
	FromAction string `protobuf:"bytes,6,opt,name=fromAction,proto3" json:"fromAction,omitempty"`
	ToStep     string `protobuf:"bytes,7,opt,name=toStep,proto3" json:"toStep,omitempty"`
	ToAction   string `protobuf:"bytes,8,opt,name=toAction,proto3" json:"toAction,omitempty"`
	TTL        int32  `protobuf:"varint,9,opt,name=ttl,proto3" json:"ttl,omitempty"`
}

func (m *Notify) Reset()         { *m = Notify{} }
func (m *Notify) String() string { return proto.CompactTextString(m) }
func (*Notify) ProtoMessage()    {}
func (*Notify) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{9}
}
func (m *Notify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Notify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Notify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Notify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Notify.Merge(m, src)
}
func (m *Notify) XXX_Size() int {
	return m.Size()
}
func (m *Notify) XXX_DiscardUnknown() {
	xxx_messageInfo_Notify.DiscardUnknown(m)
}

var xxx_messageInfo_Notify proto.InternalMessageInfo

func (m *Notify) GetUserID() uint32 {
	if m != nil {
		return m.UserID
	}
	return 0
}

func (m *Notify) GetCrowd() []byte {
	if m != nil {
		return m.Crowd
	}
	return nil
}

func (m *Notify) GetTenantID() uint64 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *Notify) GetWorkflowID() uint64 {
	if m != nil {
		return m.WorkflowID
	}
	return 0
}

func (m *Notify) GetFromStep() string {
	if m != nil {
		return m.FromStep
	}
	return ""
}

func (m *Notify) GetFromAction() string {
	if m != nil {
		return m.FromAction
	}
	return ""
}

func (m *Notify) GetToStep() string {
	if m != nil {
		return m.ToStep
	}
	return ""
}

func (m *Notify) GetToAction() string {
	if m != nil {
		return m.ToAction
	}
	return ""
}

func (m *Notify) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

// Workflow is process definition
type Workflow struct {
	ID       uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	TenantID uint64 `protobuf:"varint,2,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	Name     string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Steps    []Step `protobuf:"bytes,4,rep,name=steps,proto3" json:"steps"`
	Duration int64  `protobuf:"varint,5,opt,name=duration,proto3" json:"duration,omitempty"`
}

func (m *Workflow) Reset()         { *m = Workflow{} }
func (m *Workflow) String() string { return proto.CompactTextString(m) }
func (*Workflow) ProtoMessage()    {}
func (*Workflow) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{10}
}
func (m *Workflow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Workflow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Workflow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Workflow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Workflow.Merge(m, src)
}
func (m *Workflow) XXX_Size() int {
	return m.Size()
}
func (m *Workflow) XXX_DiscardUnknown() {
	xxx_messageInfo_Workflow.DiscardUnknown(m)
}

var xxx_messageInfo_Workflow proto.InternalMessageInfo

func (m *Workflow) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Workflow) GetTenantID() uint64 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *Workflow) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Workflow) GetSteps() []Step {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *Workflow) GetDuration() int64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// WorkflowInstance workflow instance
type WorkflowInstance struct {
	Snapshot   Workflow              `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot"`
	InstanceID uint64                `protobuf:"varint,2,opt,name=instanceID,proto3" json:"instanceID,omitempty"`
	LoaderMeta []byte                `protobuf:"bytes,3,opt,name=loaderMeta,proto3" json:"loaderMeta,omitempty"`
	Loader     BMLoader              `protobuf:"varint,4,opt,name=loader,proto3,enum=metapb.BMLoader" json:"loader,omitempty"`
	TotalCrowd uint64                `protobuf:"varint,5,opt,name=totalCrowd,proto3" json:"totalCrowd,omitempty"`
	Workers    uint64                `protobuf:"varint,6,opt,name=workers,proto3" json:"workers,omitempty"`
	StartedAt  int64                 `protobuf:"varint,7,opt,name=startedAt,proto3" json:"startedAt,omitempty"`
	StoppedAt  int64                 `protobuf:"varint,8,opt,name=stoppedAt,proto3" json:"stoppedAt,omitempty"`
	Version    uint64                `protobuf:"varint,9,opt,name=version,proto3" json:"version,omitempty"`
	State      WorkflowInstanceState `protobuf:"varint,10,opt,name=state,proto3,enum=metapb.WorkflowInstanceState" json:"state,omitempty"`
}

func (m *WorkflowInstance) Reset()         { *m = WorkflowInstance{} }
func (m *WorkflowInstance) String() string { return proto.CompactTextString(m) }
func (*WorkflowInstance) ProtoMessage()    {}
func (*WorkflowInstance) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{11}
}
func (m *WorkflowInstance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInstance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInstance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInstance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInstance.Merge(m, src)
}
func (m *WorkflowInstance) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInstance) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInstance.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInstance proto.InternalMessageInfo

func (m *WorkflowInstance) GetSnapshot() Workflow {
	if m != nil {
		return m.Snapshot
	}
	return Workflow{}
}

func (m *WorkflowInstance) GetInstanceID() uint64 {
	if m != nil {
		return m.InstanceID
	}
	return 0
}

func (m *WorkflowInstance) GetLoaderMeta() []byte {
	if m != nil {
		return m.LoaderMeta
	}
	return nil
}

func (m *WorkflowInstance) GetLoader() BMLoader {
	if m != nil {
		return m.Loader
	}
	return RawLoader
}

func (m *WorkflowInstance) GetTotalCrowd() uint64 {
	if m != nil {
		return m.TotalCrowd
	}
	return 0
}

func (m *WorkflowInstance) GetWorkers() uint64 {
	if m != nil {
		return m.Workers
	}
	return 0
}

func (m *WorkflowInstance) GetStartedAt() int64 {
	if m != nil {
		return m.StartedAt
	}
	return 0
}

func (m *WorkflowInstance) GetStoppedAt() int64 {
	if m != nil {
		return m.StoppedAt
	}
	return 0
}

func (m *WorkflowInstance) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *WorkflowInstance) GetState() WorkflowInstanceState {
	if m != nil {
		return m.State
	}
	return Starting
}

// WorkflowInstanceSnapshot workflow instance snapshpot
type WorkflowInstanceSnapshot struct {
	Snapshot  WorkflowInstance `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot"`
	Timestamp int64            `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	States    []StepState      `protobuf:"bytes,3,rep,name=states,proto3" json:"states"`
}

func (m *WorkflowInstanceSnapshot) Reset()         { *m = WorkflowInstanceSnapshot{} }
func (m *WorkflowInstanceSnapshot) String() string { return proto.CompactTextString(m) }
func (*WorkflowInstanceSnapshot) ProtoMessage()    {}
func (*WorkflowInstanceSnapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{12}
}
func (m *WorkflowInstanceSnapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInstanceSnapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInstanceSnapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInstanceSnapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInstanceSnapshot.Merge(m, src)
}
func (m *WorkflowInstanceSnapshot) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInstanceSnapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInstanceSnapshot.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInstanceSnapshot proto.InternalMessageInfo

func (m *WorkflowInstanceSnapshot) GetSnapshot() WorkflowInstance {
	if m != nil {
		return m.Snapshot
	}
	return WorkflowInstance{}
}

func (m *WorkflowInstanceSnapshot) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *WorkflowInstanceSnapshot) GetStates() []StepState {
	if m != nil {
		return m.States
	}
	return nil
}

// WorkflowInstanceWorkerState workflow instance state. instance : instanceState = 1 : N
type WorkflowInstanceWorkerState struct {
	TenantID   uint64      `protobuf:"varint,1,opt,name=tenantID,proto3" json:"tenantID,omitempty"`
	WorkflowID uint64      `protobuf:"varint,2,opt,name=workflowID,proto3" json:"workflowID,omitempty"`
	Index      uint32      `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	States     []StepState `protobuf:"bytes,4,rep,name=states,proto3" json:"states"`
	Version    uint64      `protobuf:"varint,5,opt,name=version,proto3" json:"version,omitempty"`
	StopAt     int64       `protobuf:"varint,6,opt,name=stopAt,proto3" json:"stopAt,omitempty"`
}

func (m *WorkflowInstanceWorkerState) Reset()         { *m = WorkflowInstanceWorkerState{} }
func (m *WorkflowInstanceWorkerState) String() string { return proto.CompactTextString(m) }
func (*WorkflowInstanceWorkerState) ProtoMessage()    {}
func (*WorkflowInstanceWorkerState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{13}
}
func (m *WorkflowInstanceWorkerState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkflowInstanceWorkerState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkflowInstanceWorkerState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkflowInstanceWorkerState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkflowInstanceWorkerState.Merge(m, src)
}
func (m *WorkflowInstanceWorkerState) XXX_Size() int {
	return m.Size()
}
func (m *WorkflowInstanceWorkerState) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkflowInstanceWorkerState.DiscardUnknown(m)
}

var xxx_messageInfo_WorkflowInstanceWorkerState proto.InternalMessageInfo

func (m *WorkflowInstanceWorkerState) GetTenantID() uint64 {
	if m != nil {
		return m.TenantID
	}
	return 0
}

func (m *WorkflowInstanceWorkerState) GetWorkflowID() uint64 {
	if m != nil {
		return m.WorkflowID
	}
	return 0
}

func (m *WorkflowInstanceWorkerState) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *WorkflowInstanceWorkerState) GetStates() []StepState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *WorkflowInstanceWorkerState) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *WorkflowInstanceWorkerState) GetStopAt() int64 {
	if m != nil {
		return m.StopAt
	}
	return 0
}

// CountState step count state
type CountState struct {
	Step  string `protobuf:"bytes,1,opt,name=step,proto3" json:"step,omitempty"`
	Count uint64 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *CountState) Reset()         { *m = CountState{} }
func (m *CountState) String() string { return proto.CompactTextString(m) }
func (*CountState) ProtoMessage()    {}
func (*CountState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{14}
}
func (m *CountState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CountState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CountState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CountState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CountState.Merge(m, src)
}
func (m *CountState) XXX_Size() int {
	return m.Size()
}
func (m *CountState) XXX_DiscardUnknown() {
	xxx_messageInfo_CountState.DiscardUnknown(m)
}

var xxx_messageInfo_CountState proto.InternalMessageInfo

func (m *CountState) GetStep() string {
	if m != nil {
		return m.Step
	}
	return ""
}

func (m *CountState) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

// InstanceCountState active instance count state
type InstanceCountState struct {
	Snapshot Workflow     `protobuf:"bytes,1,opt,name=snapshot,proto3" json:"snapshot"`
	States   []CountState `protobuf:"bytes,2,rep,name=states,proto3" json:"states"`
	Total    uint64       `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *InstanceCountState) Reset()         { *m = InstanceCountState{} }
func (m *InstanceCountState) String() string { return proto.CompactTextString(m) }
func (*InstanceCountState) ProtoMessage()    {}
func (*InstanceCountState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{15}
}
func (m *InstanceCountState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceCountState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceCountState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceCountState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceCountState.Merge(m, src)
}
func (m *InstanceCountState) XXX_Size() int {
	return m.Size()
}
func (m *InstanceCountState) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceCountState.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceCountState proto.InternalMessageInfo

func (m *InstanceCountState) GetSnapshot() Workflow {
	if m != nil {
		return m.Snapshot
	}
	return Workflow{}
}

func (m *InstanceCountState) GetStates() []CountState {
	if m != nil {
		return m.States
	}
	return nil
}

func (m *InstanceCountState) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

// StepState workflow step state.
type StepState struct {
	Step       Step     `protobuf:"bytes,1,opt,name=step,proto3" json:"step"`
	TotalCrowd uint64   `protobuf:"varint,2,opt,name=totalCrowd,proto3" json:"totalCrowd,omitempty"`
	Loader     BMLoader `protobuf:"varint,3,opt,name=loader,proto3,enum=metapb.BMLoader" json:"loader,omitempty"`
	LoaderMeta []byte   `protobuf:"bytes,4,opt,name=loaderMeta,proto3" json:"loaderMeta,omitempty"`
}

func (m *StepState) Reset()         { *m = StepState{} }
func (m *StepState) String() string { return proto.CompactTextString(m) }
func (*StepState) ProtoMessage()    {}
func (*StepState) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{16}
}
func (m *StepState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StepState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StepState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StepState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StepState.Merge(m, src)
}
func (m *StepState) XXX_Size() int {
	return m.Size()
}
func (m *StepState) XXX_DiscardUnknown() {
	xxx_messageInfo_StepState.DiscardUnknown(m)
}

var xxx_messageInfo_StepState proto.InternalMessageInfo

func (m *StepState) GetStep() Step {
	if m != nil {
		return m.Step
	}
	return Step{}
}

func (m *StepState) GetTotalCrowd() uint64 {
	if m != nil {
		return m.TotalCrowd
	}
	return 0
}

func (m *StepState) GetLoader() BMLoader {
	if m != nil {
		return m.Loader
	}
	return RawLoader
}

func (m *StepState) GetLoaderMeta() []byte {
	if m != nil {
		return m.LoaderMeta
	}
	return nil
}

// Step is a step of the work flow
type Step struct {
	Name        string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Execution   Execution `protobuf:"bytes,2,opt,name=execution,proto3" json:"execution"`
	EnterAction string    `protobuf:"bytes,3,opt,name=enterAction,proto3" json:"enterAction,omitempty"`
	LeaveAction string    `protobuf:"bytes,4,opt,name=leaveAction,proto3" json:"leaveAction,omitempty"`
	TTL         int32     `protobuf:"varint,5,opt,name=ttl,proto3" json:"ttl,omitempty"`
}

func (m *Step) Reset()         { *m = Step{} }
func (m *Step) String() string { return proto.CompactTextString(m) }
func (*Step) ProtoMessage()    {}
func (*Step) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{17}
}
func (m *Step) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Step) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Step.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Step) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Step.Merge(m, src)
}
func (m *Step) XXX_Size() int {
	return m.Size()
}
func (m *Step) XXX_DiscardUnknown() {
	xxx_messageInfo_Step.DiscardUnknown(m)
}

var xxx_messageInfo_Step proto.InternalMessageInfo

func (m *Step) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Step) GetExecution() Execution {
	if m != nil {
		return m.Execution
	}
	return Execution{}
}

func (m *Step) GetEnterAction() string {
	if m != nil {
		return m.EnterAction
	}
	return ""
}

func (m *Step) GetLeaveAction() string {
	if m != nil {
		return m.LeaveAction
	}
	return ""
}

func (m *Step) GetTTL() int32 {
	if m != nil {
		return m.TTL
	}
	return 0
}

// Execution is node operation in a seqence of executions.
// A node may have the following roles:
// 1. DirectExecution
// 2. BranchExecution
// 3. ParallelExecution
type Execution struct {
	Type     ExectuionType        `protobuf:"varint,1,opt,name=type,proto3,enum=metapb.ExectuionType" json:"type,omitempty"`
	Timer    *TimerExecution      `protobuf:"bytes,2,opt,name=timer,proto3" json:"timer,omitempty"`
	Direct   *DirectExecution     `protobuf:"bytes,3,opt,name=direct,proto3" json:"direct,omitempty"`
	Branches []ConditionExecution `protobuf:"bytes,4,rep,name=branches,proto3" json:"branches"`
	Parallel ParallelExecution    `protobuf:"bytes,5,opt,name=parallel,proto3" json:"parallel"`
}

func (m *Execution) Reset()         { *m = Execution{} }
func (m *Execution) String() string { return proto.CompactTextString(m) }
func (*Execution) ProtoMessage()    {}
func (*Execution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{18}
}
func (m *Execution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Execution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Execution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Execution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Execution.Merge(m, src)
}
func (m *Execution) XXX_Size() int {
	return m.Size()
}
func (m *Execution) XXX_DiscardUnknown() {
	xxx_messageInfo_Execution.DiscardUnknown(m)
}

var xxx_messageInfo_Execution proto.InternalMessageInfo

func (m *Execution) GetType() ExectuionType {
	if m != nil {
		return m.Type
	}
	return Direct
}

func (m *Execution) GetTimer() *TimerExecution {
	if m != nil {
		return m.Timer
	}
	return nil
}

func (m *Execution) GetDirect() *DirectExecution {
	if m != nil {
		return m.Direct
	}
	return nil
}

func (m *Execution) GetBranches() []ConditionExecution {
	if m != nil {
		return m.Branches
	}
	return nil
}

func (m *Execution) GetParallel() ParallelExecution {
	if m != nil {
		return m.Parallel
	}
	return ParallelExecution{}
}

// TimerExecution is a timer performable operation
type TimerExecution struct {
	Condition *Expr  `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition,omitempty"`
	Cron      string `protobuf:"bytes,2,opt,name=cron,proto3" json:"cron,omitempty"`
	NextStep  string `protobuf:"bytes,3,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *TimerExecution) Reset()         { *m = TimerExecution{} }
func (m *TimerExecution) String() string { return proto.CompactTextString(m) }
func (*TimerExecution) ProtoMessage()    {}
func (*TimerExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{19}
}
func (m *TimerExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimerExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimerExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimerExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimerExecution.Merge(m, src)
}
func (m *TimerExecution) XXX_Size() int {
	return m.Size()
}
func (m *TimerExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_TimerExecution.DiscardUnknown(m)
}

var xxx_messageInfo_TimerExecution proto.InternalMessageInfo

func (m *TimerExecution) GetCondition() *Expr {
	if m != nil {
		return m.Condition
	}
	return nil
}

func (m *TimerExecution) GetCron() string {
	if m != nil {
		return m.Cron
	}
	return ""
}

func (m *TimerExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// ParallelExecution is a parallel execution
type ParallelExecution struct {
	NextStep  string      `protobuf:"bytes,1,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
	Parallels []Execution `protobuf:"bytes,2,rep,name=parallels,proto3" json:"parallels"`
}

func (m *ParallelExecution) Reset()         { *m = ParallelExecution{} }
func (m *ParallelExecution) String() string { return proto.CompactTextString(m) }
func (*ParallelExecution) ProtoMessage()    {}
func (*ParallelExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{20}
}
func (m *ParallelExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParallelExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParallelExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParallelExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParallelExecution.Merge(m, src)
}
func (m *ParallelExecution) XXX_Size() int {
	return m.Size()
}
func (m *ParallelExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_ParallelExecution.DiscardUnknown(m)
}

var xxx_messageInfo_ParallelExecution proto.InternalMessageInfo

func (m *ParallelExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

func (m *ParallelExecution) GetParallels() []Execution {
	if m != nil {
		return m.Parallels
	}
	return nil
}

// DirectExecution is a directly performable operation
type DirectExecution struct {
	NextStep string `protobuf:"bytes,1,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *DirectExecution) Reset()         { *m = DirectExecution{} }
func (m *DirectExecution) String() string { return proto.CompactTextString(m) }
func (*DirectExecution) ProtoMessage()    {}
func (*DirectExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{21}
}
func (m *DirectExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DirectExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectExecution.Merge(m, src)
}
func (m *DirectExecution) XXX_Size() int {
	return m.Size()
}
func (m *DirectExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectExecution.DiscardUnknown(m)
}

var xxx_messageInfo_DirectExecution proto.InternalMessageInfo

func (m *DirectExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// ConditionExecution is selecting multiple operations to satisfy the operation of the conditional operation
type ConditionExecution struct {
	Condition Expr       `protobuf:"bytes,1,opt,name=condition,proto3" json:"condition"`
	Execution *Execution `protobuf:"bytes,2,opt,name=execution,proto3" json:"execution,omitempty"`
	NextStep  string     `protobuf:"bytes,3,opt,name=nextStep,proto3" json:"nextStep,omitempty"`
}

func (m *ConditionExecution) Reset()         { *m = ConditionExecution{} }
func (m *ConditionExecution) String() string { return proto.CompactTextString(m) }
func (*ConditionExecution) ProtoMessage()    {}
func (*ConditionExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{22}
}
func (m *ConditionExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConditionExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConditionExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConditionExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConditionExecution.Merge(m, src)
}
func (m *ConditionExecution) XXX_Size() int {
	return m.Size()
}
func (m *ConditionExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_ConditionExecution.DiscardUnknown(m)
}

var xxx_messageInfo_ConditionExecution proto.InternalMessageInfo

func (m *ConditionExecution) GetCondition() Expr {
	if m != nil {
		return m.Condition
	}
	return Expr{}
}

func (m *ConditionExecution) GetExecution() *Execution {
	if m != nil {
		return m.Execution
	}
	return nil
}

func (m *ConditionExecution) GetNextStep() string {
	if m != nil {
		return m.NextStep
	}
	return ""
}

// Expr expr
type Expr struct {
	Value []byte         `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	Type  ExprResultType `protobuf:"varint,2,opt,name=type,proto3,enum=metapb.ExprResultType" json:"type,omitempty"`
}

func (m *Expr) Reset()         { *m = Expr{} }
func (m *Expr) String() string { return proto.CompactTextString(m) }
func (*Expr) ProtoMessage()    {}
func (*Expr) Descriptor() ([]byte, []int) {
	return fileDescriptor_3b5ea8fe65782bcc, []int{23}
}
func (m *Expr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Expr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Expr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Expr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Expr.Merge(m, src)
}
func (m *Expr) XXX_Size() int {
	return m.Size()
}
func (m *Expr) XXX_DiscardUnknown() {
	xxx_messageInfo_Expr.DiscardUnknown(m)
}

var xxx_messageInfo_Expr proto.InternalMessageInfo

func (m *Expr) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Expr) GetType() ExprResultType {
	if m != nil {
		return m.Type
	}
	return BoolResult
}

func init() {
	proto.RegisterEnum("metapb.BMLoader", BMLoader_name, BMLoader_value)
	proto.RegisterEnum("metapb.WorkflowInstanceState", WorkflowInstanceState_name, WorkflowInstanceState_value)
	proto.RegisterEnum("metapb.EventType", EventType_name, EventType_value)
	proto.RegisterEnum("metapb.Group", Group_name, Group_value)
	proto.RegisterEnum("metapb.ExectuionType", ExectuionType_name, ExectuionType_value)
	proto.RegisterEnum("metapb.ExprResultType", ExprResultType_name, ExprResultType_value)
	proto.RegisterType((*ShardBitmapPutMeta)(nil), "metapb.ShardBitmapPutMeta")
	proto.RegisterType((*ShardBitmapLoadMeta)(nil), "metapb.ShardBitmapLoadMeta")
	proto.RegisterType((*IDValue)(nil), "metapb.IDValue")
	proto.RegisterType((*IDSet)(nil), "metapb.IDSet")
	proto.RegisterType((*Event)(nil), "metapb.Event")
	proto.RegisterType((*UpdateCrowdEvent)(nil), "metapb.UpdateCrowdEvent")
	proto.RegisterType((*UpdateWorkflowEvent)(nil), "metapb.UpdateWorkflowEvent")
	proto.RegisterType((*UserEvent)(nil), "metapb.UserEvent")
	proto.RegisterType((*KV)(nil), "metapb.KV")
	proto.RegisterType((*Notify)(nil), "metapb.Notify")
	proto.RegisterType((*Workflow)(nil), "metapb.Workflow")
	proto.RegisterType((*WorkflowInstance)(nil), "metapb.WorkflowInstance")
	proto.RegisterType((*WorkflowInstanceSnapshot)(nil), "metapb.WorkflowInstanceSnapshot")
	proto.RegisterType((*WorkflowInstanceWorkerState)(nil), "metapb.WorkflowInstanceWorkerState")
	proto.RegisterType((*CountState)(nil), "metapb.CountState")
	proto.RegisterType((*InstanceCountState)(nil), "metapb.InstanceCountState")
	proto.RegisterType((*StepState)(nil), "metapb.StepState")
	proto.RegisterType((*Step)(nil), "metapb.Step")
	proto.RegisterType((*Execution)(nil), "metapb.Execution")
	proto.RegisterType((*TimerExecution)(nil), "metapb.TimerExecution")
	proto.RegisterType((*ParallelExecution)(nil), "metapb.ParallelExecution")
	proto.RegisterType((*DirectExecution)(nil), "metapb.DirectExecution")
	proto.RegisterType((*ConditionExecution)(nil), "metapb.ConditionExecution")
	proto.RegisterType((*Expr)(nil), "metapb.Expr")
}

func init() { proto.RegisterFile("meta.proto", fileDescriptor_3b5ea8fe65782bcc) }

var fileDescriptor_3b5ea8fe65782bcc = []byte{
	// 1486 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x4b, 0x6f, 0xdb, 0xc6,
	0x13, 0x17, 0x1f, 0x92, 0xc5, 0x91, 0xad, 0xd0, 0x9b, 0xc4, 0x7f, 0xc5, 0xc9, 0x5f, 0x31, 0x88,
	0xb4, 0x70, 0x85, 0xc4, 0x0e, 0x1c, 0x34, 0x87, 0xb4, 0x87, 0x46, 0x56, 0xd2, 0x0a, 0x8e, 0x5b,
	0x83, 0x76, 0x9c, 0x5b, 0x01, 0x5a, 0x5a, 0xdb, 0x44, 0x24, 0x92, 0x20, 0x97, 0x7e, 0x7c, 0x80,
	0xde, 0x03, 0xf4, 0xd2, 0x4b, 0x8f, 0xbd, 0xf7, 0x63, 0xe4, 0x18, 0xf4, 0x50, 0xf4, 0x14, 0xb4,
	0xce, 0x67, 0xe8, 0xb1, 0x40, 0xb1, 0xb3, 0xbb, 0x7c, 0x48, 0x7e, 0x04, 0xbd, 0xed, 0xcc, 0xfc,
	0xe6, 0x3d, 0x3b, 0x5c, 0x02, 0x8c, 0x29, 0xf3, 0x56, 0xa2, 0x38, 0x64, 0x21, 0xa9, 0xf1, 0x73,
	0xb4, 0xb7, 0xf8, 0xe0, 0xc0, 0x67, 0x87, 0xe9, 0xde, 0xca, 0x20, 0x1c, 0xaf, 0x1e, 0x84, 0x07,
	0xe1, 0x2a, 0x8a, 0xf7, 0xd2, 0x7d, 0xa4, 0x90, 0xc0, 0x93, 0x50, 0x73, 0x0e, 0x80, 0x6c, 0x1f,
	0x7a, 0xf1, 0xb0, 0xeb, 0xb3, 0xb1, 0x17, 0x6d, 0xa5, 0x6c, 0x93, 0x32, 0x8f, 0xd8, 0x60, 0xbc,
	0xa6, 0xa7, 0x2d, 0x6d, 0x49, 0x5b, 0x9e, 0x75, 0xf9, 0x91, 0xdc, 0x02, 0x83, 0xb1, 0x51, 0x4b,
	0x5f, 0xd2, 0x96, 0xe7, 0xba, 0x33, 0x67, 0xef, 0xef, 0x1a, 0x3b, 0x3b, 0x2f, 0x5c, 0xce, 0x23,
	0xf7, 0x60, 0x6e, 0xef, 0x94, 0xd1, 0x64, 0x8b, 0xc6, 0x68, 0xaa, 0x65, 0x70, 0x90, 0x5b, 0x66,
	0x3a, 0x2f, 0xe1, 0x7a, 0xc1, 0xd1, 0x8b, 0xd0, 0x1b, 0x5e, 0xe0, 0xe9, 0x06, 0x54, 0x77, 0x42,
	0xe6, 0x09, 0x5f, 0xa6, 0x2b, 0x08, 0xb2, 0x00, 0xb5, 0x84, 0xab, 0x27, 0xd2, 0xba, 0xa4, 0x9c,
	0x47, 0x30, 0xd3, 0xef, 0xed, 0x7a, 0xa3, 0x94, 0x72, 0xc5, 0x23, 0x7e, 0x40, 0x63, 0x96, 0x2b,
	0x08, 0x42, 0xc0, 0x64, 0xa7, 0x11, 0x45, 0x6b, 0x96, 0x8b, 0x67, 0xe7, 0x31, 0x54, 0xfb, 0xbd,
	0x6d, 0xca, 0xc8, 0x03, 0xa8, 0x21, 0x2a, 0x69, 0x69, 0x4b, 0xc6, 0x72, 0x63, 0xed, 0xda, 0x8a,
	0xa8, 0xe2, 0x8a, 0xb4, 0xd9, 0x35, 0xdf, 0xbe, 0xbf, 0x5b, 0x71, 0x25, 0xc8, 0xf9, 0x5d, 0x83,
	0xea, 0xb3, 0x23, 0x1a, 0x30, 0xf2, 0x89, 0xb4, 0xca, 0x5d, 0x35, 0xd7, 0xe6, 0x95, 0x1a, 0x0a,
	0x77, 0x4e, 0x23, 0x2a, 0x1c, 0x71, 0x58, 0x9a, 0xd0, 0x18, 0x9d, 0x37, 0x72, 0xd8, 0xcb, 0x84,
	0xc6, 0x08, 0x75, 0x51, 0x4c, 0x9e, 0x40, 0x23, 0x8d, 0x86, 0x1e, 0xa3, 0xeb, 0x71, 0x78, 0x2c,
	0xea, 0xd7, 0x58, 0x6b, 0x65, 0xe8, 0x5c, 0x24, 0x94, 0x8a, 0x60, 0xb2, 0x0e, 0x4d, 0x41, 0xbe,
	0x0a, 0xe3, 0xd7, 0xfb, 0xa3, 0xf0, 0xb8, 0x65, 0xa2, 0xfa, 0xed, 0xb2, 0xba, 0x92, 0x0a, 0x0b,
	0x13, 0x2a, 0xce, 0xf7, 0x60, 0x4f, 0x7a, 0x21, 0x6d, 0x80, 0x63, 0x29, 0xef, 0xf7, 0x30, 0x51,
	0xd3, 0x2d, 0x70, 0x78, 0xb9, 0xfd, 0x60, 0x48, 0x4f, 0xc4, 0x4c, 0xb8, 0x82, 0xe0, 0xdc, 0x41,
	0x96, 0xc4, 0xac, 0x2b, 0x08, 0xa7, 0x0f, 0xd7, 0xcf, 0x09, 0x83, 0xac, 0x41, 0x5d, 0x19, 0x44,
	0x07, 0x8d, 0x35, 0x5b, 0x45, 0xad, 0x80, 0xb2, 0x03, 0x19, 0xce, 0xf9, 0x41, 0x03, 0x2b, 0xab,
	0x1f, 0x1f, 0x0b, 0x5e, 0x41, 0x19, 0xe0, 0x9c, 0x2b, 0x29, 0xb2, 0x08, 0x75, 0x46, 0x03, 0x2f,
	0x60, 0xfd, 0x9e, 0x9c, 0xa3, 0x8c, 0x9e, 0x48, 0xcc, 0x98, 0x4a, 0xec, 0x1e, 0x98, 0x43, 0x8f,
	0x79, 0x2d, 0x13, 0x47, 0x02, 0x54, 0x44, 0x1b, 0xbb, 0x32, 0x16, 0x94, 0x3a, 0xf7, 0x41, 0xdf,
	0xd8, 0x3d, 0x7f, 0x7c, 0xc5, 0x14, 0xea, 0xa2, 0x00, 0x48, 0x38, 0xff, 0x68, 0x50, 0xfb, 0x36,
	0x64, 0xfe, 0xfe, 0xe9, 0x85, 0x21, 0x67, 0x95, 0xd3, 0x0b, 0x95, 0x2b, 0x25, 0x62, 0x5c, 0x9a,
	0x88, 0x39, 0x95, 0xc8, 0x22, 0xd4, 0xf7, 0xe3, 0x70, 0xbc, 0xcd, 0x68, 0xd4, 0xaa, 0xe2, 0xf8,
	0x67, 0x34, 0xd7, 0xe5, 0xe7, 0xa7, 0x03, 0xe6, 0x87, 0x41, 0xab, 0x86, 0xd2, 0x02, 0x87, 0x47,
	0xc9, 0x42, 0xd4, 0x9c, 0x41, 0x99, 0xa4, 0x30, 0x9e, 0x50, 0x6a, 0xd5, 0x85, 0x4d, 0x45, 0xab,
	0x1d, 0x61, 0x2d, 0x69, 0xcb, 0xd5, 0xf2, 0x8e, 0x70, 0x7e, 0xd2, 0xa0, 0xae, 0x5a, 0x4a, 0x16,
	0x40, 0xf7, 0x87, 0x62, 0xa2, 0xba, 0xb5, 0xb3, 0xf7, 0x77, 0xf5, 0x7e, 0xcf, 0xd5, 0xfd, 0xe1,
	0xa5, 0x4d, 0x23, 0x60, 0x06, 0xde, 0x98, 0x62, 0x0d, 0x2c, 0x17, 0xcf, 0x64, 0x19, 0xaa, 0x09,
	0xa3, 0x51, 0x22, 0x3b, 0x35, 0xab, 0x3a, 0xc5, 0x03, 0x95, 0xbd, 0x12, 0x00, 0x6e, 0x79, 0x98,
	0xc6, 0x1e, 0x46, 0xcd, 0x2b, 0x61, 0xb8, 0x19, 0xed, 0xfc, 0xad, 0x83, 0xad, 0x42, 0xeb, 0x07,
	0x09, 0xf3, 0x82, 0x01, 0xe5, 0x93, 0x99, 0x04, 0x5e, 0x94, 0x1c, 0x86, 0xec, 0xaa, 0xc9, 0x54,
	0x38, 0x5e, 0x52, 0x5f, 0xea, 0x67, 0x09, 0x14, 0x38, 0x5c, 0x3e, 0x0a, 0xbd, 0x21, 0x8d, 0xf9,
	0xe2, 0x93, 0xf7, 0xa3, 0xc0, 0x21, 0xcb, 0x50, 0x13, 0x14, 0xb6, 0xb2, 0x99, 0x7b, 0xec, 0x6e,
	0xbe, 0x40, 0xbe, 0x2b, 0xe5, 0xdc, 0x12, 0xe3, 0x5b, 0x51, 0xac, 0x8b, 0xaa, 0xf0, 0x94, 0x73,
	0x48, 0x0b, 0x66, 0xf8, 0x18, 0xd0, 0x38, 0xc1, 0xce, 0x9a, 0xae, 0x22, 0xc9, 0x1d, 0xb0, 0x12,
	0xe6, 0xc5, 0x8c, 0x0e, 0x9f, 0x32, 0xec, 0xac, 0xe1, 0xe6, 0x0c, 0x21, 0x0d, 0xa3, 0x08, 0xa5,
	0x75, 0x25, 0x95, 0x0c, 0x6e, 0xf5, 0x88, 0xc6, 0x09, 0xaf, 0xa1, 0x25, 0xac, 0x4a, 0x92, 0x3c,
	0xe2, 0x8d, 0xf0, 0x18, 0x6d, 0x01, 0x06, 0xfe, 0xff, 0xc9, 0x52, 0xa9, 0xb2, 0x6e, 0x73, 0x90,
	0x2b, 0xb0, 0xce, 0x2f, 0x1a, 0xb4, 0xa6, 0x00, 0xaa, 0x96, 0x4f, 0xa6, 0xea, 0xdf, 0xba, 0xc8,
	0xe8, 0x54, 0x1f, 0xee, 0x80, 0xc5, 0xfc, 0x31, 0x4d, 0x98, 0x37, 0x8e, 0xb0, 0x0d, 0x86, 0x9b,
	0x33, 0xc8, 0x2a, 0xd4, 0xd0, 0x3f, 0xff, 0x90, 0x18, 0xc5, 0xa5, 0xcc, 0xa7, 0x06, 0x03, 0x54,
	0x4b, 0x5f, 0xc0, 0x9c, 0xdf, 0x34, 0xb8, 0x3d, 0xe9, 0xf3, 0x15, 0x96, 0x13, 0xd1, 0xa5, 0xa9,
	0xd5, 0x2e, 0xbd, 0xa1, 0xfa, 0xc5, 0x3b, 0xd4, 0x28, 0xee, 0xd0, 0x3c, 0x44, 0xf3, 0xa3, 0x42,
	0x2c, 0x76, 0xa6, 0x5a, 0xee, 0x0c, 0xff, 0x6c, 0xb2, 0x30, 0x7a, 0xca, 0x70, 0x10, 0x0c, 0x57,
	0x52, 0xce, 0x63, 0x80, 0xf5, 0x30, 0x0d, 0x98, 0x48, 0x81, 0x80, 0xc9, 0xef, 0x89, 0xfc, 0x70,
	0xe2, 0x19, 0xd7, 0x11, 0x47, 0xa8, 0xcf, 0x30, 0x12, 0xce, 0x1b, 0x0d, 0x88, 0x2a, 0x42, 0xc1,
	0xc0, 0x7f, 0xb9, 0x2e, 0x0f, 0xb3, 0x2c, 0x75, 0xcc, 0x92, 0x28, 0x8d, 0xdc, 0xee, 0x44, 0x9a,
	0x37, 0xa0, 0x8a, 0x43, 0x2e, 0x17, 0xa1, 0x20, 0x9c, 0x9f, 0x35, 0xb0, 0xb2, 0xc2, 0x90, 0x4f,
	0x0b, 0xa9, 0x9c, 0xbf, 0x12, 0x44, 0x7a, 0xe5, 0x2b, 0xa4, 0x4f, 0x5d, 0xa1, 0xfc, 0x32, 0x1a,
	0x57, 0x5f, 0xc6, 0xc2, 0xb5, 0x36, 0x27, 0xaf, 0xb5, 0xf3, 0xab, 0x06, 0x26, 0xae, 0x4e, 0xb5,
	0xc2, 0xb4, 0xc2, 0x0a, 0xfb, 0x1c, 0x2c, 0x7a, 0x42, 0x07, 0x29, 0x6e, 0xa6, 0x89, 0x57, 0xc2,
	0x33, 0x25, 0x90, 0x81, 0xe7, 0x48, 0xb2, 0x04, 0x0d, 0x1a, 0x30, 0x1a, 0xcb, 0x45, 0x2c, 0x96,
	0x62, 0x91, 0xc5, 0x11, 0x23, 0xea, 0x1d, 0x51, 0x89, 0x30, 0x05, 0xa2, 0xc0, 0x52, 0xdb, 0xba,
	0x7a, 0xce, 0xb6, 0x7e, 0xa3, 0x83, 0x95, 0x79, 0x27, 0x9f, 0x95, 0xde, 0x3a, 0x37, 0x8b, 0xe1,
	0xb1, 0xd4, 0x0f, 0x83, 0xc2, 0x7b, 0xe7, 0x3e, 0x54, 0xf9, 0x4d, 0x53, 0x0f, 0x9e, 0x05, 0x85,
	0xdd, 0xe1, 0xcc, 0xcc, 0xa2, 0x2b, 0x40, 0x7c, 0xce, 0x87, 0x7e, 0x4c, 0x07, 0x4c, 0xbe, 0x78,
	0xfe, 0xa7, 0xe0, 0x3d, 0xe4, 0xe6, 0x78, 0x09, 0x23, 0x5f, 0x42, 0x7d, 0x2f, 0xf6, 0x82, 0xc1,
	0x61, 0x76, 0x35, 0x16, 0xf3, 0xa1, 0x09, 0x86, 0x3e, 0x07, 0x4f, 0x56, 0x2d, 0xd3, 0x20, 0x5f,
	0x40, 0x3d, 0xf2, 0x62, 0x6f, 0x34, 0xa2, 0x22, 0xeb, 0xc6, 0xda, 0x2d, 0xa5, 0xbd, 0x25, 0xf9,
	0x53, 0xca, 0x4a, 0xc1, 0x19, 0x41, 0xb3, 0x9c, 0x04, 0xe9, 0x80, 0x35, 0x50, 0x4e, 0x27, 0xc7,
	0xed, 0xd9, 0x49, 0x14, 0xbb, 0xb9, 0x98, 0xb7, 0x7e, 0x10, 0xcb, 0x0e, 0x5b, 0x2e, 0x9e, 0xf9,
	0xde, 0x08, 0xe8, 0x09, 0xc3, 0x6f, 0xac, 0x68, 0x60, 0x46, 0x3b, 0xfb, 0x30, 0x3f, 0x15, 0x52,
	0x49, 0x41, 0x2b, 0x2b, 0xf0, 0x39, 0x52, 0xa1, 0xaa, 0xfb, 0x74, 0xf1, 0x1c, 0x65, 0x48, 0xe7,
	0x01, 0x5c, 0x9b, 0xa8, 0xf5, 0x65, 0x5e, 0x9c, 0x1f, 0x35, 0x20, 0xd3, 0x85, 0x26, 0x0f, 0xaf,
	0xa8, 0x84, 0xf2, 0x9b, 0xd7, 0x63, 0xf5, 0x63, 0xc6, 0xbe, 0x38, 0xf0, 0x97, 0x15, 0xeb, 0x1b,
	0x30, 0xb9, 0x97, 0xf2, 0xfb, 0x5f, 0xbd, 0xbc, 0x48, 0xa7, 0xf0, 0xfe, 0x6f, 0xe6, 0x13, 0x89,
	0x1d, 0xa2, 0x49, 0x3a, 0x2a, 0x3c, 0xd7, 0x3b, 0x5b, 0x50, 0x57, 0xd7, 0x9b, 0xcc, 0x81, 0xe5,
	0x7a, 0xc7, 0x82, 0xb0, 0x2b, 0x64, 0x16, 0xea, 0x1b, 0xbb, 0x92, 0xd2, 0xc8, 0x3c, 0xcc, 0x6d,
	0xec, 0xe2, 0xef, 0x8c, 0x64, 0xe9, 0xe4, 0x06, 0xd8, 0xeb, 0x23, 0x7f, 0xf0, 0xfa, 0x30, 0x4c,
	0x13, 0x2a, 0xb9, 0x46, 0x67, 0x13, 0x6e, 0x9e, 0xfb, 0x11, 0xe4, 0xf6, 0xb6, 0xf9, 0x77, 0xd7,
	0x0f, 0x0e, 0xec, 0x0a, 0x69, 0xc0, 0x8c, 0x9b, 0x06, 0x01, 0x27, 0x34, 0x21, 0x0a, 0xa3, 0x88,
	0x53, 0x3a, 0x17, 0x6d, 0x8b, 0x4f, 0xb0, 0x6d, 0x74, 0x9e, 0x83, 0x95, 0xfd, 0x62, 0x70, 0x1c,
	0x7f, 0x08, 0xf3, 0xb3, 0x5d, 0x21, 0xd7, 0xe1, 0x5a, 0xe1, 0x09, 0x8f, 0x4c, 0x8d, 0x2c, 0x00,
	0x29, 0xbf, 0xbb, 0x91, 0xaf, 0x77, 0x9e, 0x43, 0xf5, 0xeb, 0x38, 0x4c, 0x23, 0x62, 0xc3, 0x6c,
	0x8f, 0xee, 0x7b, 0xe9, 0x88, 0x21, 0x6d, 0x57, 0x78, 0x1e, 0x3b, 0xe2, 0xf3, 0x15, 0x44, 0xa9,
	0xe4, 0x6a, 0xe4, 0x26, 0xcc, 0x0b, 0xee, 0x77, 0x29, 0xcb, 0xd8, 0x7a, 0xe7, 0x2b, 0x98, 0x2b,
	0xad, 0x01, 0x02, 0x50, 0x13, 0x03, 0x65, 0x57, 0x88, 0x05, 0x55, 0xbc, 0x32, 0xb6, 0xc6, 0xd9,
	0x5d, 0xbc, 0x86, 0xb6, 0xce, 0xc3, 0x56, 0xb3, 0x6d, 0x1b, 0x9d, 0x15, 0x68, 0x96, 0x5b, 0x41,
	0x9a, 0x00, 0xdd, 0x30, 0x1c, 0x09, 0x8e, 0xa8, 0x7c, 0x77, 0x53, 0x52, 0x5a, 0xf7, 0xce, 0xbb,
	0xbf, 0xda, 0x95, 0xb7, 0x67, 0x6d, 0xed, 0xdd, 0x59, 0x5b, 0xfb, 0xf3, 0xac, 0xad, 0xbd, 0xf9,
	0xd0, 0xae, 0xbc, 0xfb, 0xd0, 0xae, 0xfc, 0xf1, 0xa1, 0x5d, 0xd9, 0xab, 0xe1, 0x4f, 0xed, 0xa3,
	0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x45, 0xb6, 0xcc, 0x82, 0x19, 0x0f, 0x00, 0x00,
}

func (m *ShardBitmapPutMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardBitmapPutMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardBitmapPutMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BytesPerShard != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.BytesPerShard))
		i--
		dAtA[i] = 0x18
	}
	if m.TTL != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardBitmapLoadMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardBitmapLoadMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardBitmapLoadMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Shards != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Shards))
		i--
		dAtA[i] = 0x18
	}
	if m.Total != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IDValue) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDValue) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDValue) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IDSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IDSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IDSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Values[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateWorkflow != nil {
		{
			size, err := m.UpdateWorkflow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UpdateCrowd != nil {
		{
			size, err := m.UpdateCrowd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateCrowdEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCrowdEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateCrowdEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Crowd) > 0 {
		i -= len(m.Crowd)
		copy(dAtA[i:], m.Crowd)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Crowd)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.WorkflowID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.WorkflowID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateWorkflowEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateWorkflowEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateWorkflowEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Workflow.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UserEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.WorkflowID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.WorkflowID))
		i--
		dAtA[i] = 0x18
	}
	if m.TenantID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x10
	}
	if m.UserID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KV) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KV) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KV) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Notify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Notify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Notify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ToAction) > 0 {
		i -= len(m.ToAction)
		copy(dAtA[i:], m.ToAction)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.ToAction)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ToStep) > 0 {
		i -= len(m.ToStep)
		copy(dAtA[i:], m.ToStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.ToStep)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FromAction) > 0 {
		i -= len(m.FromAction)
		copy(dAtA[i:], m.FromAction)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.FromAction)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.FromStep) > 0 {
		i -= len(m.FromStep)
		copy(dAtA[i:], m.FromStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.FromStep)))
		i--
		dAtA[i] = 0x2a
	}
	if m.WorkflowID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.WorkflowID))
		i--
		dAtA[i] = 0x20
	}
	if m.TenantID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Crowd) > 0 {
		i -= len(m.Crowd)
		copy(dAtA[i:], m.Crowd)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Crowd)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.UserID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Workflow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Workflow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Workflow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Duration != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Steps) > 0 {
		for iNdEx := len(m.Steps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Steps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TenantID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WorkflowInstance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInstance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInstance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x50
	}
	if m.Version != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x48
	}
	if m.StoppedAt != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.StoppedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.StartedAt != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.StartedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.Workers != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Workers))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalCrowd != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TotalCrowd))
		i--
		dAtA[i] = 0x28
	}
	if m.Loader != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Loader))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LoaderMeta) > 0 {
		i -= len(m.LoaderMeta)
		copy(dAtA[i:], m.LoaderMeta)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.LoaderMeta)))
		i--
		dAtA[i] = 0x1a
	}
	if m.InstanceID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.InstanceID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WorkflowInstanceSnapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInstanceSnapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInstanceSnapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.States) > 0 {
		for iNdEx := len(m.States) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.States[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *WorkflowInstanceWorkerState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkflowInstanceWorkerState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkflowInstanceWorkerState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StopAt != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.StopAt))
		i--
		dAtA[i] = 0x30
	}
	if m.Version != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if len(m.States) > 0 {
		for iNdEx := len(m.States) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.States[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Index != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.WorkflowID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.WorkflowID))
		i--
		dAtA[i] = 0x10
	}
	if m.TenantID != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TenantID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CountState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CountState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CountState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Step) > 0 {
		i -= len(m.Step)
		copy(dAtA[i:], m.Step)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Step)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstanceCountState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceCountState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceCountState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if len(m.States) > 0 {
		for iNdEx := len(m.States) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.States[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StepState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StepState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StepState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LoaderMeta) > 0 {
		i -= len(m.LoaderMeta)
		copy(dAtA[i:], m.LoaderMeta)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.LoaderMeta)))
		i--
		dAtA[i] = 0x22
	}
	if m.Loader != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Loader))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalCrowd != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TotalCrowd))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Step.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Step) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Step) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Step) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TTL != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.TTL))
		i--
		dAtA[i] = 0x28
	}
	if len(m.LeaveAction) > 0 {
		i -= len(m.LeaveAction)
		copy(dAtA[i:], m.LeaveAction)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.LeaveAction)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EnterAction) > 0 {
		i -= len(m.EnterAction)
		copy(dAtA[i:], m.EnterAction)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.EnterAction)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Execution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Execution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Execution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Parallel.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Branches) > 0 {
		for iNdEx := len(m.Branches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Branches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Direct != nil {
		{
			size, err := m.Direct.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Timer != nil {
		{
			size, err := m.Timer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimerExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimerExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimerExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Cron) > 0 {
		i -= len(m.Cron)
		copy(dAtA[i:], m.Cron)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Cron)))
		i--
		dAtA[i] = 0x12
	}
	if m.Condition != nil {
		{
			size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParallelExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParallelExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParallelExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Parallels) > 0 {
		for iNdEx := len(m.Parallels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Parallels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMeta(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DirectExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DirectExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConditionExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConditionExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConditionExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NextStep) > 0 {
		i -= len(m.NextStep)
		copy(dAtA[i:], m.NextStep)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.NextStep)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Execution != nil {
		{
			size, err := m.Execution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMeta(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Condition.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMeta(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Expr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintMeta(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMeta(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMeta(dAtA []byte, offset int, v uint64) int {
	offset -= sovMeta(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ShardBitmapPutMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovMeta(uint64(m.TTL))
	}
	if m.BytesPerShard != 0 {
		n += 1 + sovMeta(uint64(m.BytesPerShard))
	}
	return n
}

func (m *ShardBitmapLoadMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Total != 0 {
		n += 1 + sovMeta(uint64(m.Total))
	}
	if m.Shards != 0 {
		n += 1 + sovMeta(uint64(m.Shards))
	}
	return n
}

func (m *IDValue) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *IDSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMeta(uint64(m.Type))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.UpdateCrowd != nil {
		l = m.UpdateCrowd.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.UpdateWorkflow != nil {
		l = m.UpdateWorkflow.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *UpdateCrowdEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkflowID != 0 {
		n += 1 + sovMeta(uint64(m.WorkflowID))
	}
	if m.Index != 0 {
		n += 1 + sovMeta(uint64(m.Index))
	}
	l = len(m.Crowd)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *UpdateWorkflowEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Workflow.Size()
	n += 1 + l + sovMeta(uint64(l))
	return n
}

func (m *UserEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovMeta(uint64(m.UserID))
	}
	if m.TenantID != 0 {
		n += 1 + sovMeta(uint64(m.TenantID))
	}
	if m.WorkflowID != 0 {
		n += 1 + sovMeta(uint64(m.WorkflowID))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	return n
}

func (m *KV) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *Notify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserID != 0 {
		n += 1 + sovMeta(uint64(m.UserID))
	}
	l = len(m.Crowd)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.TenantID != 0 {
		n += 1 + sovMeta(uint64(m.TenantID))
	}
	if m.WorkflowID != 0 {
		n += 1 + sovMeta(uint64(m.WorkflowID))
	}
	l = len(m.FromStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.FromAction)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.ToStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.ToAction)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovMeta(uint64(m.TTL))
	}
	return n
}

func (m *Workflow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMeta(uint64(m.ID))
	}
	if m.TenantID != 0 {
		n += 1 + sovMeta(uint64(m.TenantID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, e := range m.Steps {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Duration != 0 {
		n += 1 + sovMeta(uint64(m.Duration))
	}
	return n
}

func (m *WorkflowInstance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Snapshot.Size()
	n += 1 + l + sovMeta(uint64(l))
	if m.InstanceID != 0 {
		n += 1 + sovMeta(uint64(m.InstanceID))
	}
	l = len(m.LoaderMeta)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Loader != 0 {
		n += 1 + sovMeta(uint64(m.Loader))
	}
	if m.TotalCrowd != 0 {
		n += 1 + sovMeta(uint64(m.TotalCrowd))
	}
	if m.Workers != 0 {
		n += 1 + sovMeta(uint64(m.Workers))
	}
	if m.StartedAt != 0 {
		n += 1 + sovMeta(uint64(m.StartedAt))
	}
	if m.StoppedAt != 0 {
		n += 1 + sovMeta(uint64(m.StoppedAt))
	}
	if m.Version != 0 {
		n += 1 + sovMeta(uint64(m.Version))
	}
	if m.State != 0 {
		n += 1 + sovMeta(uint64(m.State))
	}
	return n
}

func (m *WorkflowInstanceSnapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Snapshot.Size()
	n += 1 + l + sovMeta(uint64(l))
	if m.Timestamp != 0 {
		n += 1 + sovMeta(uint64(m.Timestamp))
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	return n
}

func (m *WorkflowInstanceWorkerState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TenantID != 0 {
		n += 1 + sovMeta(uint64(m.TenantID))
	}
	if m.WorkflowID != 0 {
		n += 1 + sovMeta(uint64(m.WorkflowID))
	}
	if m.Index != 0 {
		n += 1 + sovMeta(uint64(m.Index))
	}
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovMeta(uint64(m.Version))
	}
	if m.StopAt != 0 {
		n += 1 + sovMeta(uint64(m.StopAt))
	}
	return n
}

func (m *CountState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Step)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovMeta(uint64(m.Count))
	}
	return n
}

func (m *InstanceCountState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Snapshot.Size()
	n += 1 + l + sovMeta(uint64(l))
	if len(m.States) > 0 {
		for _, e := range m.States {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovMeta(uint64(m.Total))
	}
	return n
}

func (m *StepState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Step.Size()
	n += 1 + l + sovMeta(uint64(l))
	if m.TotalCrowd != 0 {
		n += 1 + sovMeta(uint64(m.TotalCrowd))
	}
	if m.Loader != 0 {
		n += 1 + sovMeta(uint64(m.Loader))
	}
	l = len(m.LoaderMeta)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *Step) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = m.Execution.Size()
	n += 1 + l + sovMeta(uint64(l))
	l = len(m.EnterAction)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.LeaveAction)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.TTL != 0 {
		n += 1 + sovMeta(uint64(m.TTL))
	}
	return n
}

func (m *Execution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMeta(uint64(m.Type))
	}
	if m.Timer != nil {
		l = m.Timer.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Direct != nil {
		l = m.Direct.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	l = m.Parallel.Size()
	n += 1 + l + sovMeta(uint64(l))
	return n
}

func (m *TimerExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Condition != nil {
		l = m.Condition.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.Cron)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *ParallelExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if len(m.Parallels) > 0 {
		for _, e := range m.Parallels {
			l = e.Size()
			n += 1 + l + sovMeta(uint64(l))
		}
	}
	return n
}

func (m *DirectExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *ConditionExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Condition.Size()
	n += 1 + l + sovMeta(uint64(l))
	if m.Execution != nil {
		l = m.Execution.Size()
		n += 1 + l + sovMeta(uint64(l))
	}
	l = len(m.NextStep)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	return n
}

func (m *Expr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMeta(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMeta(uint64(m.Type))
	}
	return n
}

func sovMeta(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMeta(x uint64) (n int) {
	return sovMeta(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShardBitmapPutMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardBitmapPutMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardBitmapPutMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesPerShard", wireType)
			}
			m.BytesPerShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesPerShard |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardBitmapLoadMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardBitmapLoadMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardBitmapLoadMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Shards |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDValue) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDValue: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDValue: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IDSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IDSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IDSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, IDValue{})
			if err := m.Values[len(m.Values)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &UserEvent{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCrowd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateCrowd == nil {
				m.UpdateCrowd = &UpdateCrowdEvent{}
			}
			if err := m.UpdateCrowd.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateWorkflow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateWorkflow == nil {
				m.UpdateWorkflow = &UpdateWorkflowEvent{}
			}
			if err := m.UpdateWorkflow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCrowdEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCrowdEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCrowdEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowID", wireType)
			}
			m.WorkflowID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkflowID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crowd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crowd = append(m.Crowd[:0], dAtA[iNdEx:postIndex]...)
			if m.Crowd == nil {
				m.Crowd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateWorkflowEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateWorkflowEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateWorkflowEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workflow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Workflow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowID", wireType)
			}
			m.WorkflowID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkflowID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, KV{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KV) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KV: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KV: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Notify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Notify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Notify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			m.UserID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserID |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crowd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crowd = append(m.Crowd[:0], dAtA[iNdEx:postIndex]...)
			if m.Crowd == nil {
				m.Crowd = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowID", wireType)
			}
			m.WorkflowID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkflowID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Workflow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Workflow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Workflow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, Step{})
			if err := m.Steps[len(m.Steps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInstance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInstance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInstance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			m.InstanceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstanceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoaderMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoaderMeta = append(m.LoaderMeta[:0], dAtA[iNdEx:postIndex]...)
			if m.LoaderMeta == nil {
				m.LoaderMeta = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loader", wireType)
			}
			m.Loader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loader |= BMLoader(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCrowd", wireType)
			}
			m.TotalCrowd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCrowd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Workers", wireType)
			}
			m.Workers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Workers |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoppedAt", wireType)
			}
			m.StoppedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoppedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= WorkflowInstanceState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInstanceSnapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInstanceSnapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInstanceSnapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, StepState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkflowInstanceWorkerState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkflowInstanceWorkerState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkflowInstanceWorkerState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TenantID", wireType)
			}
			m.TenantID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TenantID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowID", wireType)
			}
			m.WorkflowID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkflowID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, StepState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopAt", wireType)
			}
			m.StopAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Step = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceCountState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceCountState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceCountState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.States = append(m.States, CountState{})
			if err := m.States[len(m.States)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StepState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StepState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StepState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Step.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCrowd", wireType)
			}
			m.TotalCrowd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCrowd |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loader", wireType)
			}
			m.Loader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Loader |= BMLoader(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoaderMeta", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoaderMeta = append(m.LoaderMeta[:0], dAtA[iNdEx:postIndex]...)
			if m.LoaderMeta == nil {
				m.LoaderMeta = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Step) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Step: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Step: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnterAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnterAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaveAction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaveAction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TTL", wireType)
			}
			m.TTL = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TTL |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Execution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Execution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Execution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ExectuionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timer == nil {
				m.Timer = &TimerExecution{}
			}
			if err := m.Timer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direct", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Direct == nil {
				m.Direct = &DirectExecution{}
			}
			if err := m.Direct.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, ConditionExecution{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Parallel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimerExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimerExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimerExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Condition == nil {
				m.Condition = &Expr{}
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cron = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parallels = append(m.Parallels, Execution{})
			if err := m.Parallels[len(m.Parallels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConditionExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConditionExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConditionExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Condition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Condition.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Execution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Execution == nil {
				m.Execution = &Execution{}
			}
			if err := m.Execution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextStep", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextStep = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMeta
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMeta
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ExprResultType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMeta(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMeta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMeta(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMeta
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMeta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMeta
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMeta
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMeta
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMeta        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMeta          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMeta = fmt.Errorf("proto: unexpected end of group")
)
